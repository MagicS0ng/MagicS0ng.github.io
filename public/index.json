[{"content":"自我介绍 C++ i++ ,++i i++是右值，++i是左值 如果在一条语句内执行i++, 会先获取i的值，然后执行语句，执行结束后i自增1 如果在一条语句内执行++i, 会先对i自增1，然后执行语句 补充：一般来讲，i++ 的执行操作为：使用临时对象保存i的值，然后执行i+1，返回临时对象；++i 直接对i自增，不涉及临时变量 for-loop for(int i = 0;i\u0026lt;10;i++/++i\u0026gt;): ++i 与i++ 输出i，结果一致吗？ 一致\nfor()的使用\nfor如果使用之前声明的变量，可以直接以for (;condition;expression) 循环，循环开始时会获取变量的初始值，判断本次执行是否满足条件，满足则执行，执行完循环体，循环变量更新，不满足则结束循环 也可以使用for(init;condition;expression) 3. 其他想到的补充：\n对象初始化 回答会根据传递的参数，调用不同的重载。也可以根据成员变成，隐式构造；也可以将构造函数声明为explicit的，禁止隐式构造。 面试官问还有吗？不知道问的什么，然后继续问了虚函数。\n虚函数 成员函数，通过virtual修饰，子类继承时可以选择是否重载，也可以通过virtual 成员函数=0的方式声明为纯虚函数，子类必须重载。 子类继承父类时，构造子类时需要先构造父类，析构时通过声明父类析构为virtual，先析构子类，后析构父类。 补充：\n纯虚函数的父类为虚基类，无法实例化。 如果构造函数中包含虚函数，因为子类还没有构造，没有虚函数指针，因此会调用父类的虚函数。 虚函数，成员函数会存储在代码段，虚函数表存储在rodata段 在析构函数中调用虚函数时：基类析构函数在执行时，派生类部分的对象已经被销毁，虚函数表的指针可能不再有效，导致虚函数调用的行为不可预测。 inline 因为inline会原地展开，没有具体的地址，无法通过指针访问 static函数不能是虚函数，static成员函数是类级别的，无法通过多态调用。 子类可以访问父类的静态资源，只要子类有访问权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; class Base { public: static int x; public: static void staticFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Base static function\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int Base::x = 30; class Derived : public Base { public: static int x; public: static void derivedStaticFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived static function\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int Derived::x = 40; int main() { Base::staticFunction(); // 访问父类的静态成员函数 Derived::staticFunction(); // 子类也可以通过类名访问父类的静态成员函数 std::cout \u0026lt;\u0026lt; Base::x \u0026lt;\u0026lt; std::endl; // 访问父类的静态成员变量 std::cout \u0026lt;\u0026lt; Derived::x \u0026lt;\u0026lt; std::endl; // 访问子类的静态成员变量,同名资源 优先输出子类的 } 输出\n1 2 Base static function Base static function 虚函数指针 虚函数指针存在对象空间内，只有在调用时，才会通过虚函数指针，访问虚函数表，调用对应的虚函数。\nnew delete, malloc free C++可以视作C的超集，C++继承了C的malloc和free\nnew / delete new 动态申请内存，返回对应对象类型的指针， 调用类的构造函数，并进行初始化，访问了内存，涉及到虚实地址变换 申请失败会抛出异常std::bad_alloc。 delete 释放通过new申请的空间； 调用类的析构函数 补充：可以通过new(nothrow)返回空指针; new和delete是C++运算符可以重载。是否访问内存取决于具体的初始化逻辑，虚实地址变换由操作系统完成。 malloc / free malloc 申请内存，返回void类型的指针， 不进行初始化，因此没有访存 申请失败，返回NULL free 释放通过malloc申请的空间； 补充：malloc和free是C的函数。不支持重载 内存布局 栈： 自动管理，速度比较快，超出作用域自定析构 堆：手动管理，通过裸指针申请时，必须手动析构；也可以通过智能指针管理 全局区data：初始化的全局变量和静态变量 代码区text：代码段，存储函数，和类的静态成员函数 bss区：未初始化的全局变量和静态变量，默认为0 rodata区：只读数据，常量 线程 进程区别 进程 进程享有自己的地址空间，因此多进程之间是隔离的，一个进程的崩溃往往不会导致其他进程崩溃 进程通信比较复杂 进程是资源分配的基本单位 线程 多个线程共享一个进程的地址空间，因此一个线程崩溃有可能导致其他线程的崩溃 线程通信简单，因此需要频繁交互任务可以使用多线程。 补充：进程通信包括：管道，共享内存，消息队列，socket，信号，信号量；线程通信主要包括：互斥锁，条件变量，信号量，原子操作，互斥量，读写锁。 数据库索引 尴尬，答成引擎了。然后又回答一遍\nB+： 多路平衡，高度比较矮，快速查询，叶子节点为链表结构，支持范围查询，非叶子节点存储索引节点，叶子节点存储数据 B：不支持范围查询，非叶子节点也可以存储数据 单列索引：单个字段创建索引 联合索引：多个字段创建索引，需要主要最左匹配原则 补充：哈希索引：快速查找，无法排序，不支持范围查询， 项目 问到有没有测过并发量。回答没有，但是根据之前测试线程池的经验，应该可以支持1w用户。\n网络部分 浏览器访问url到渲染页面的具体过程 DNS解析 有缓存先查缓存 没有缓存，查询根域名服务器，根域名服务器通过树状结构查询顶级域名服务器，顶级域名查询负责该域名的权威域名服务器 权威域名服务器返回IP地址 TCP握手 IP 同一个子网，通过arp寻找对应的mac，不同子网通过默认路由转发，通过路由器自动更新下一跳的mac地址寻找目标mac地址 封装http消息，请求行，请求头，请求体， 通过交换机或路由器将信息转为二进制流，发送到目标主机 服务器收到后通过拆包，协议栈自底向上到达应用层，知道是http消息，取出对应的资源，以响应行：status_code等，响应头，响应体，经协议栈自顶向下发送 客户端收到消息，通过浏览器渲染得到页面 如何加快http的速度 选择压缩算法，压缩消息体 服务器负载均衡，返回最近的最快的服务器 选择合适的协议，因为TCP很慢，所以http3.0 使用了UDP实现的quic 将用户访问过的资源，在本地缓存 补充：其他优化方式：合并多个css、js使用一个http连接发送，减少请求数量；异步加载js；使用高效的图像压缩算法，压缩图像 补充缓存： 浏览器缓存：通过设置适当的缓存策略（如Cache-Control、Expires）在浏览器端缓存常用资源，避免每次请求都重新从服务器加载资源，显著提高页面加载速度。 CDN缓存：内容分发网络（CDN）将资源缓存到离用户更近的节点，通过地理位置分发减少网络延迟，提升响应速度。 服务器端缓存：对于常用的动态资源（如数据库查询结果），可以使用 Redis 或 Memcached 等缓存技术，减少数据库的压力，快速返回常见请求的结果。 服务工作者缓存：现代浏览器提供服务工作者（Service Workers）来缓存资源并提供离线支持，使得即使没有网络，用户也可以继续使用应用程序。 对如何成为一个优秀的开发者有什么看法 主观题。。。\n手撕 二叉树最近公共祖先 ACM模式，写出函数讲解思路\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct TreeNode{ int val; TreeNode *left; TreeNode *right; TreeNode():val(0),left(nullptr), right(nullptr){} TreeNode(int _val):val(_val),left(nullptr), right(nullptr){} }; TreeNode * commonAncestor(TreeNode *root, TreeNode *p, TreeNode *q){ if(!root||p==root||q==root) return p; auto left = commonAncestor(root-\u0026gt;left, p, q); auto right = commonAncestor(root-\u0026gt;right, p, q); if(left\u0026amp;\u0026amp;right) return root; return left?left:right; } ","permalink":"http://localhost:14745/posts/%E5%BF%AB%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E9%9D%A2/","summary":"12/09/2024 快手广告部门客户端一面","title":"快手客户端一面"},{"content":"无自我介绍 熟悉的C++版本 C++11以后的基本都了解一些， 没有特别针对某个版本.\n智能指针 shared_ptr: 支持拷贝、移动，可以作为返回值类型，避免大对象的拷贝. 引用计数是线程安全的 unique_ptr：支持移动，可以通过转移所有权的方式，将对象的所有权转移给另一个独占指针 weal_ptr: 支持拷贝，可以作为返回值类型，但是不能转移所有权，只能通过weak_ptr转成shared_ptr gdb gcc有用过吗 不怎么用gdb gcc有了解\ngcc如何预处理 忘了，回答gcc有参数控制\n1 gcc -E main.c -o main.i 如何获取不进行链接的代码 忘了，回答gcc有参数控制\n1 gcc -c main.c -o main.o 线程安全的单例模式 通过C++11std::call_once实现 对指针判空执行两次，因为第一次判断为空后初始化前，可能其他线程已经初始化了，所以要两次判空 问有没有其他的，回答原子变量应该也行，不是很了解。 了解压缩算法吗 不知道为啥问这个问题，面试官接着问是否了解哈夫曼，然后让讲一下自己了解的压缩算法。回答了科研做的图像压缩。\n项目 项目结构 略\n负载均衡怎么做的 通过roundRobin方式实现，返回一个连接数量少的服务器；接着问道有考虑延迟吗，回答没有，因为是在单个机器测试的。\n单例模板基类是什么 通过模板类是实现一个单例基类，子类通过CRTP的方式实现单例。\nQt键盘鼠标事件 键盘事件：keyPressEvent keyReleaseEvent 鼠标事件：mousePressEvent mouseReleaseEvent mouseMoveEvent linux相关 docker如何建立目录映射 回答，在创建容器时通过-v指定宿主目录和容器目录的映射关系。\ntop如何根据内存占用排序 回答不知道，自己使用的基于top封装的btop，可以通过命令控制\n1 top -o %MEM 如何查找进程的句柄， 回答不太了解。可以使用ps命令查询进程状态。 查询大模型得到： 进程句柄：操作系统为每个进程分配的一个唯一标识符。它主要用于操作系统内核和其他系统组件之间进行进程管理和通信。以下是关于进程句柄的一些关键点：\n1 ls -l /proc/\u0026lt;pid\u0026gt;/fd 查看进程端口占用 1 netstat -anp 查看进程打开的文件句柄 回答不知道，查询大模型得到：\n1 lsof -p \u0026lt;pid\u0026gt; git 回答稀碎，只会使用push, pull\ngit rebase git rebase可以将一个分支的更改应用到另一个分支上，可以用来\n更新分支： 将当前分支的更改应用到最新的主分支（如 main 或 master）上，以保持代码的最新状态。 例如，如果你在一个功能分支上工作，而主分支上有新的提交，你可以使用 rebase 将功能分支的更改应用到最新的主分支上。 线性化提交历史： rebase 可以使提交历史更加线性，避免合并提交（merge commit）的出现，从而使提交历史更清晰。 例如，如果你从 main 分支派生了一个功能分支，并且 main 分支上有新的提交，rebase 可以将你的功能分支的提交重新应用到 main 分支的最新提交之上。 解决冲突： 在 rebase 过程中，如果遇到冲突，Git 会暂停并提示你解决冲突。解决冲突后，你可以继续 rebase 过程。 例如，如果你的功能分支和 main 分支在同一个文件上进行了修改，rebase 会提示你解决这些冲突。 git 如何创建分支 回答使用checkout 具体是：\n1 git checkout -b \u0026lt;branch_name\u0026gt; ","permalink":"http://localhost:14745/posts/%E9%87%91%E5%B1%B1%E4%BA%8C%E9%9D%A2/","summary":"12/05/2024 金山wpsC++二面","title":"金山二面"},{"content":"自我介绍：略 经常使用的容器 map k,v可以存储操作id和函数，作为回调。\nsort()使用了哪种排序算法 sort() 底部使用了多种排序算法： 快排，堆排\n当数据量大，分布随机时，使用快速排序 数据量小，使用插入排序 递归深度过深时使用堆排序 排序算法的使用场景 快排：无序数组效率会很高，但是有序数组效率会很低，所以快速排序只适用于无序数组。 归并排序：内存有限的情况下，可以使用多路归并 插入排序： 基本有序的数据，适合用插入排序。 智能指针 weak_ptr可以提升为shared_ptr吗？ 可以。\nshared_ptr: 会使用计数器来记录引用次数，当引用次数为0时，释放对象。 weak_ptr：weak_ptr实现弱引用，可以通过.lock() 提升为 shared_ptr 使用一段代码体现C++面向对象的思想 首先，C++面向对象的特性有三个\n封装 继承 多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Base{ public: Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base constructoer\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void getObjName() { std::cout \u0026lt;\u0026lt; \u0026#34;This is a Base object\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base destructor\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived:public Base{ public: Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived constructoer\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void getObjName() override { std::cout \u0026lt;\u0026lt; \u0026#34;This is a Derived object\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived destructor\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base *p = new Derived(); p-\u0026gt;getObjName(); delete p; } 这段代码会输出:\n1 2 3 4 5 Base constructoer Derived constructoer This is a Derived object Derived destructor Base destructor 面试官接着问了两个类的大小， 回答没有考虑继承时的虚函数指针，所以回答的两个都是1。 实际上因为对象会有一个虚函数指针，对于个一个64位的机器，指针的大小是8字节，所以两个类的大小都是8字节。\n1 std::cout \u0026lt;\u0026lt; sizeof(Base) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sizeof(Derived) \u0026lt;\u0026lt; std::endl; 输出\n1 8 8 实现字符串数字相加，相减 当时实现时考虑的场景太多了，所以没有实现。 而且要注意，做相加或相减时，要将字符转为整数。 所以具体实现时，要考虑\n实现基础的 正数相加 大数减小数 特殊情况，特殊判定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // 1. 首先要将两个字符串的前缀0 去掉 std::string trimLeadingZeors(const std::string \u0026amp;str) { size_t nonZeroIdx = str.find_first_not_of(\u0026#39;0\u0026#39;); if(nonZeroIdx == std::string::npos) return \u0026#39;0\u0026#39;; // 此时全部是0 return str.substr(nonZeroIdx); } // 2. 比较两个字符串数字绝对值的大小 bool isAbsGreaterOrEqual(const std::string \u0026amp;a, const std::string \u0026amp;b) { std::string aTrimmed = trimLeadingZeors(a); std::string bTrimmed = trimLeadingZeors(b); if(aTrimmed.size() != bTrimmed.size()) return aTrimmed.size() \u0026gt; bTrimmed.size(); return aTrimmed \u0026gt; bTrimmed; } // 3. 两个整数字符串加法 std::string addStrings(const std::string \u0026amp;a, const std::string \u0026amp;b) { std::string result; int carry = 0, sum=0; int i = a.size()-1, j = b.size()-1; while(i\u0026gt;=0 || j\u0026gt;=0 || carry) { int digitA = (i\u0026gt;=0)?a[i--]-\u0026#39;0\u0026#39;:0; int digitB = (j\u0026gt;=0)?b[i--]-\u0026#39;0\u0026#39;:0; sum = digitA + digitB + carry; carry = sum / 10; result.push_back(sum % 10 + \u0026#39;0\u0026#39;); } std::reverse(result.begin(), result.end()); return result; } // 4. 字符串减法， a\u0026gt;=b std::string subStrings(const std::string \u0026amp;a, const std::string \u0026amp;b) { std::string result; int borrow = 0, diff=0; int i = a.size()-1, j = b.size()-1; while(i\u0026gt;=0 || j\u0026gt;=0) { int digitA = (i\u0026gt;=0)?a[i--]-\u0026#39;0\u0026#39;:0; int digitB = (j\u0026gt;=0)?b[i--]-\u0026#39;0\u0026#39;:0; diff = digitA - digitB - borrow; if(diff \u0026lt; 0) { diff += 10; borrow = 1; }else { borrow = 0; } result.push_back(diff + \u0026#39;0\u0026#39;); } std::reverse(result.begin(), result.end()); return result; } // 5. 实现 任意类型的加减 std::string add(const std::string \u0026amp;num1, const std::string \u0026amp;num2) { bool isNum1Negative = (num1[0] == \u0026#39;-\u0026#39;); bool isNum2Negative = (num2[0] == \u0026#39;-\u0026#39;); std::string absNum1 = isNum1Negative ? num1.substr(1) : num1; std::string absNum2 = isNum2Negative ? num2.substr(1) : num2; if (!isNum1Negative \u0026amp;\u0026amp; !isNum2Negative) { // 都是正数 return addStrings(absNum1, absNum2); } else if (isNum1Negative \u0026amp;\u0026amp; isNum2Negative) { // 都是负数 return \u0026#34;-\u0026#34; + addStrings(absNum1, absNum2); } else if (isNum1Negative) { // num1负，num2正 if (isAbsGreaterOrEqual(absNum1, absNum2)) { return \u0026#34;-\u0026#34; + subtractStrings(absNum1, absNum2); } else { return subtractStrings(absNum2, absNum1); } } else { // num1正，num2负 if (isAbsGreaterOrEqual(absNum2, absNum1)) { return \u0026#34;-\u0026#34; + subtractStrings(absNum2, absNum1); } else { return subtractStrings(absNum1, absNum2); } } } // 字符串相减 任意 std::string subtract(const std::string \u0026amp;num1, const std::string \u0026amp;num2) { std::string negatedNum2 = (num2[0] == \u0026#39;-\u0026#39;) ? num2.substr(1) : \u0026#34;-\u0026#34; + num2; return add(num1, negatedNum2); } 最后 倒霉倒霉倒霉。面试期间，快手电话没接到，应该是约面的。结束之后去官网看已经挂了。此前快手三面因为面试官的问题有一个是特定场景，跟C++不一样没有答出来。讲解项目面试官说他没听懂😅。\n","permalink":"http://localhost:14745/posts/%E9%87%91%E5%B1%B1%E4%B8%80%E9%9D%A2/","summary":"12/03/2024 金山wpsC++一面","title":"金山一面"},{"content":"原题\nleetcode 3274 检查棋盘方格颜色是否相同 方法1 因为原题给出了棋盘的格式，所以我的想法是初始化棋盘，然后根据两个坐标访问即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { private: const string s1 = \u0026#34;01010101\u0026#34;; const string s2 = \u0026#34;10101010\u0026#34;; vector\u0026lt;string\u0026gt; grid; void init() { grid.resize(8, string(8, \u0026#39;0\u0026#39;)); for (int i = 0; i \u0026lt; 8; i++) { grid[i] = i % 2 ? s1 : s2; } } public: bool checkTwoChessboards(string coordinate1, string coordinate2) { init(); return grid[coordinate1[0] - \u0026#39;a\u0026#39;][coordinate1[1] - \u0026#39;0\u0026#39; - 1] == grid[coordinate2[0] - \u0026#39;a\u0026#39;][coordinate2[1] - \u0026#39;0\u0026#39; - 1]; } }; 时间复杂度 使用了常数时间初始化棋盘，可以视作O(1) 空间复杂度 使用了常数量的空间存储棋盘，可以视作 O(1) 方法2 方法2 就很取巧了。棋盘的横坐标是a~h ascii即为97~104，纵坐标为1~8。 举几个例子：\n(a,1)为黑色，(a,2)为白色，后边交替\u0026hellip;\u0026hellip; (b,1)为白色，(b,2)为黑色，后边交替\u0026hellip;\u0026hellip; (c,1)为黑色，(c,2)为白色，后边交替\u0026hellip;\u0026hellip; (d,1)为白色，(d,2)为黑色，后边交替\u0026hellip;\u0026hellip; 把横坐标使用ascii代替后 (97,1)为黑色，(97,2)为白色，后边交替\u0026hellip;\u0026hellip; (98,1)为白色，(98,2)为黑色，后边交替\u0026hellip;\u0026hellip; (99,1)为黑色，(99,2)为白色，后边交替\u0026hellip;\u0026hellip; (100,1)为白色，(100,2)为黑色，后边交替\u0026hellip;\u0026hellip; 总结规律： 如果横纵坐标奇偶性一致，为黑色，否则为白色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { bool same(int a, int b) { if (a % 2 \u0026amp;\u0026amp; b % 2) return true; else if (a % 2 == 0 \u0026amp;\u0026amp; b % 2 == 0) return true; return false; } public: bool checkTwoChessboards(string s, string t) { int s0 = toascii(s[0]); int s1 = s[1] - \u0026#39;0\u0026#39;; int t0 = toascii(t[0]); int t1 = t[1] - \u0026#39;0\u0026#39;; if (same(s0, s1) \u0026amp;\u0026amp; same(t0, t1) || !same(s0, s1) \u0026amp;\u0026amp; !same(t0, t1)) return true; return false; } }; 时间复杂度 O(1) 空间复杂度 O(1) ","permalink":"http://localhost:14745/posts/leetcode-3274-12-03-2024/","summary":"leetcode 3274 简单题，但是原理不简单","title":"Leetcode 3274 12/03/2024"},{"content":"std::async 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;chrono\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; // async 获取异步返回值 std::string fetchDataFromDB(std::string query) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is fetching data from DB...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); return \u0026#34;Data: \u0026#34; + query; } void use_async() { // 异步获取数据 std::future\u0026lt;std::string\u0026gt; fetchedData = std::async(std::launch::async, fetchDataFromDB, \u0026#34;query\u0026#34;); // 主线程正常进行 for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } // get() 是阻塞的， 只有数据返回后才会继续执行 std::string data = fetchedData.get(); std::cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; } int main() { use_async(); return 0; } async 的启动模式 std::launch::async 立即执行 std::launch::defer 调用std::future::get时才会执行 std::launch::deferred|std::launch::async 不同的环境执行结果不同 std::future std::future::get 调用时会阻塞，调用后std::future就会失效 std::future::wait 阻塞调用，如果任务完成就会返回，没有则继续等待，可以多次调用，但是一旦调用了std::future::get 因为对象std::future的失效，就会异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 std::string fetchDataFromDB(std::string query) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is fetching data from DB...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); return \u0026#34;Data: \u0026#34; + query; } void use_async_future_wait() { // 异步获取数据 std::future\u0026lt;std::string\u0026gt; fetchedData = std::async(std::launch::async, fetchDataFromDB, \u0026#34;query\u0026#34;); // 主线程正常进行 for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } // get() 是阻塞的， 只有数据返回后才会继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;first call `fetchedData.get()` \u0026#34; \u0026lt;\u0026lt; std::endl; fetchedData.wait(); // std::string data = fetchedData.get(); // std::cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; for (int i = 10; i \u0026lt; 20; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;call `future::wait()` again \u0026#34; \u0026lt;\u0026lt; std::endl; fetchedData.wait(); } std::packaged_task std::packaged_task可以将异步任务包装成std::future，运行在另一个线程上，可以捕获任务的返回值或异常 使用：\n创建一个std::packaged_task 对象，包装一个任务 调用std::packaged_task::get_future 获取一个std::future对象 在另一个线程上调用std::packaged_task的operator()执行任务 调用std::future::get获取返回值或异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int my_task() { std::this_thread::sleep_for(std::chrono::seconds(4)); std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is running task...\u0026#34; \u0026lt;\u0026lt; std::endl; return 42; } void use_packaged_task() { std::packaged_task\u0026lt;int()\u0026gt; task(my_task); for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;Call `task.get_future()`\u0026#34; \u0026lt;\u0026lt; std::endl; auto res = task.get_future(); std::cout \u0026lt;\u0026lt; \u0026#34;Get result from `my_task()`\u0026#34; \u0026lt;\u0026lt; std::endl; // 需要开辟一个子线程处理`std::packaged_task` 必须使用`std::move` std::packaged_task只支持移动语义 std::thread t(std::move(task)); t.detach(); std::cout \u0026lt;\u0026lt; res.get(); } std::promise std::promise也可以在线程中获取异步返回值，保存在std::future中，在另外一个线程中获取这个值或异常。\n与std::packaged_task不同的是，std::packaged_task绑定的是一个函数，也就是只有等待函数执行完才能拿到结果，\n而std::promise 可以在函数中的任意一步定义，拿到值之后可以直接在其他线程中得到值。\nstd::promise也是只支持移动操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 void set_value(std::promise\u0026lt;int\u0026gt; prom) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is setting value...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); prom.set_value(42); std::cout \u0026lt;\u0026lt; \u0026#34;promise has set value to 42\u0026#34; \u0026lt;\u0026lt; std::endl; } void use_promise() { std::promise\u0026lt;int\u0026gt; prom; std::future\u0026lt;int\u0026gt; fut = prom.get_future(); std::thread t(set_value, std::move(prom)); // 开辟的子线程会运行，但只有通过`std::future`对象才能获取到`std::promise`中的值 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else...\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for subthread to set value \u0026#34;\u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;get value for subthread: \u0026#34; \u0026lt;\u0026lt; fut.get() \u0026lt;\u0026lt; std::endl; t.join(); } // 使用promise 捕获异常 void promise_one_exception(std::promise\u0026lt;void\u0026gt; promise) { try { throw std::runtime_error(\u0026#34;Oops, Error\u0026#34;); } catch (...) { promise.set_exception(std::current_exception()); } } void use_promise_exception() { std::promise\u0026lt;void\u0026gt; promise; std::future\u0026lt;void\u0026gt; future = promise.get_future(); std::thread t(promise_one_exception, std::move(promise)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else...\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for subthread to set value \u0026#34; \u0026lt;\u0026lt; std::endl; future.wait(); try { future.get(); } catch (std::exception \u0026amp;e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } t.join(); } // 搭配std::shared_future void function(std::promise\u0026lt;int\u0026gt; \u0026amp;\u0026amp;prom) { std::this_thread::sleep_for(std::chrono::seconds(10)); prom.set_value(10); } void threadfunction(std::shared_future\u0026lt;int\u0026gt; future) { try { int result = future.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } catch (std::future_error \u0026amp;e) { std::cout \u0026lt;\u0026lt; \u0026#34;future error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } void use_shared_future() { std::promise\u0026lt;int\u0026gt; prom; std::shared_future\u0026lt;int\u0026gt; future = prom.get_future(); std::thread t1(function, std::move(prom)); std::thread t2(threadfunction, future); // 不可以通过 std::move(future)的方式传递 std::thread t3(threadfunction, future); t1.join(), t2.join(), t3.join(); } last but not least C++线程池的一种实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; class ThreadPool { using TASK = std::packaged_task\u0026lt;void()\u0026gt;; private: static std::shared_ptr\u0026lt;ThreadPool\u0026gt; _instance; std::atomic\u0026lt;int\u0026gt; _thread_count; std::atomic\u0026lt;bool\u0026gt; _stop; std::mutex _mtx; std::condition_variable _cond; std::vector\u0026lt;std::thread\u0026gt; _workers; std::queue\u0026lt;TASK\u0026gt; _tasks; private: void work_thread() { while (!this-\u0026gt;_stop.load()) { TASK task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(this-\u0026gt;_mtx); this-\u0026gt;_cond.wait(lock, [this] { return this-\u0026gt;_stop.load() || !this-\u0026gt;_tasks.empty(); }); if (this-\u0026gt;_tasks.empty()) return; task = std::move(this-\u0026gt;_tasks.front()); this-\u0026gt;_tasks.pop(); } this-\u0026gt;_thread_count--; task(); this-\u0026gt;_thread_count++; } } void start() { for (int i = 0; i \u0026lt; _thread_count; ++i) { _workers.emplace_back(\u0026amp;ThreadPool::work_thread, this); } } void stop() { _stop.store(true); _cond.notify_all(); for (auto \u0026amp;t : _workers) { if (t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Join thread with id = \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; std::endl; t.join(); } } } ThreadPool(size_t thread_count = 4) : _stop(false) { if (thread_count \u0026lt;= 1) _thread_count = 1; else _thread_count = thread_count; start(); } ThreadPool(const ThreadPool \u0026amp;other) = delete; ThreadPool \u0026amp;operator=(const ThreadPool \u0026amp;) = delete; public: ~ThreadPool() { stop(); } static std::shared_ptr\u0026lt;ThreadPool\u0026gt; GetInstance() { std::once_flag s_flag; std::call_once(s_flag, [\u0026amp;]() { if (_instance == nullptr) _instance = std::shared_ptr\u0026lt;ThreadPool\u0026gt;(new ThreadPool(4)); }); return _instance; } template \u0026lt;class F, class... Args\u0026gt; auto commit(F \u0026amp;\u0026amp;f, Args \u0026amp;\u0026amp;...args) -\u0026gt; std::future\u0026lt;decltype(f(args...))\u0026gt; { using RETURN_TYPE = decltype(f(args...)); if (_stop.load()) return std::future\u0026lt;RETURN_TYPE\u0026gt;{}; auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;RETURN_TYPE()\u0026gt;\u0026gt;( std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...)); std::future\u0026lt;RETURN_TYPE\u0026gt; res = task-\u0026gt;get_future(); { std::unique_lock\u0026lt;std::mutex\u0026gt; lck(_mtx); _tasks.emplace([task]() { (*task)(); }); } _cond.notify_one(); return res; } auto available_threads() const { return _thread_count.load(); } }; std::shared_ptr\u0026lt;ThreadPool\u0026gt; ThreadPool::_instance = nullptr; int main() { auto res = ThreadPool::GetInstance()-\u0026gt;commit( [](int a, int b) { return a + b; }, 10, 20); std::cout \u0026lt;\u0026lt; res.get() \u0026lt;\u0026lt; std::endl; }; 注意,在GetInstance()中，只能使用std::shared_ptr\u0026lt;ThreadPool\u0026gt;(new ThreadPool);的方式构造 因为make_shared无法访问私有构造函数。\n","permalink":"http://localhost:14745/posts/future-async-promise/","summary":"C++中std::future, std::packaged_task, std::promise的使用","title":"Future Async Promise"},{"content":"多线程 多线程享有一个进程的地址空间，线程切换比进程切换要简单，而且线程通信也比进程通信要简单。\nC++中使用多线程可以通过std::thread类实现。std::thread位于头文件\u0026lt;thread\u0026gt;中。 具体可以通过以下方式实现一个线程\n绑定普通函数 绑定lambda表达式 绑定函数对象 函数指针 仿函数 std::bind 初始化一个线程后，线程就会开始执行，但是线程可能会在主线程结束之后还需要运行，因此需要使用std::thread::join方法来等待线程结束。\n也可以通过std::thread::detach在主线程后台运行，主线程不会等待子线程执行结束。 绑定普通函数 1 2 3 4 5 6 7 8 9 void print() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; } void bindaThread() { std::thread t1(print); t1.join(); } 绑定类成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 class Foo { public: void print(){ std::cout \u0026lt;\u0026lt; \u0026#34;This is a class member function\u0026#34; \u0026lt;\u0026lt; std::endl; } } void bindClassMember() { Foo foo; std::thread t(\u0026amp;Foo::print, \u0026amp;foo); t.join(); } 绑定lambda 1 2 3 4 5 6 void bindLambda() { std::thread t([](){ std::cout \u0026lt;\u0026lt; \u0026#34;Bind a lambda function\u0026#34; \u0026lt;\u0026lt; std::endl; }) } 绑定仿函数 1 2 3 4 5 6 7 8 9 10 11 12 struct ClassLikeFunc { void operator()() { std::cout \u0026lt;\u0026lt; \u0026#34;Bind a class like function\u0026#34; \u0026lt;\u0026lt; std::endl; } } void bindClassLikeFunc() { std::thread t{ClassLikeFunc()}; t.join(); } 如需要传参，初始化时std::thread t(func,params)即可。\n注意 std::thread不支持拷贝构造，只能通过移动构造。 因此一个线程对象可以通过std::move()的方式将所有权转移给其他线程 std::thread默认传参是以拷贝的方式，如果要传入引用，需要通过std::ref() ","permalink":"http://localhost:14745/posts/cpp-thread-basic/","summary":"C++多线程的基础概念","title":"Cpp Thread Basic"},{"content":"leetcode 743 原题\n分析 题目要求计算从起始节点到所有节点的最短时间，也就是到最远距离的最小时间。 使用dijkstra算法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int networkDelayTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; times, int n, int k) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(n, INT_MAX / 2));// 定义图， g[i][j] for (auto\u0026amp; t : times) { g[t[0] - 1][t[1] - 1] = t[2]; } vector\u0026lt;int\u0026gt; dis(n, INT_MAX / 2), done(n); // dis[i] 表示k-\u0026gt; i的最短路 dis[k - 1] = 0; // 起始节点为k 起始距离为0 while (true) { int x = -1; for (int i = 0; i \u0026lt; n; i++) { // 遍历dis 寻找距离最短的点 if (!done[i] \u0026amp;\u0026amp; (x \u0026lt; 0 || dis[i] \u0026lt; dis[x])) { x = i; } } // 如果 没有找到未处理的点，直接返回 if (x \u0026lt; 0) return ranges::max(dis); // 如果找到的距离最小的点的距离还是inf 返回-1，表示不可达 if (dis[x] == INT_MAX / 2) return -1; done[x] = true; // 更新该节点为访问过 for (int y = 0; y \u0026lt; n; y++) { dis[y] = min(dis[y], dis[x] + g[x][y]); // 以当前节点为起始节点，更新最小距离 } } } }; 时间复杂度 初始化邻接矩阵为$O(n^2)$ 空间复杂度 使用了邻接矩阵存储图为$O(n^2)$ ","permalink":"http://localhost:14745/posts/leetcode-743/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 743"},{"content":"leetcode 3238 原题\n分析 题目定义玩家的某个颜色的球的个数大于玩家id为胜利玩家，\n因此需要统计每个玩家的对应颜色的球的数量，也就是要定义一个二维数组 $arr[playerId][ballColor]$ 表示玩家id为playerId，球颜色为ballColor的球数量。 一个玩家只能被记录一次胜利玩家，因此需要一个标记数组$tags[playerCount]$标记玩家是否已经被记录过 一旦某个玩家的$arr[playerId][ballColor]\u0026gt;playerId$，胜利玩家结果数量+1，且要将$tags[playerId]$标记为true，表示该玩家已经被记录为胜利玩家 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 1. // const int MXN =20; // int arr[MXN][11]{0}; // bool tags[MXN]{false}; class Solution { public: int winningPlayerCount(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pick) { // 2. vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; arr(n,vector\u0026lt;int\u0026gt;(11,0)); vector\u0026lt;bool\u0026gt; tags(n,false); int result = 0; for (auto pic : pick) { // playerId = pic[0]; // ballColor = pic[1]; // tags[playerId]未被记入结果时，且arr[playerId][ballColor]\u0026gt;playerId // 结果+1 将tags[playerId] 标记为true int playerId = pic[0]; int ballColor = pic[1]; ++arr[playerId][ballColor]; if (tags[playerId] == false \u0026amp;\u0026amp; arr[playerId][ballColor] \u0026gt; playerId) { result++; tags[playerId] = true; } } return result; } }; 时间复杂度 对于每个pic 都需要遍历一次 对于两个数组，需要对$n*max(y)$的数组初始化 因此时间复杂度为$O(n*max(y)+m)$ $m$为pick的长度，$n$为playerId的数量，$y$为球颜色数量 空间复杂度 需要两个数组，因此空间复杂度为$O(n*y)$\n一些问题 尚未搞明白，为什么注释1的定义方式本地可以通过leetcode无法通过，注释2的可以\n","permalink":"http://localhost:14745/posts/leetcode-3238/","summary":"Leetcode 3238 每日一题 简单题","title":"Leetcode 3238"},{"content":"原题\nleetcode 3233 真因数：对于一个数字x x除了x本身以外的所有正因数为其真因数 特殊数字的定义为：仅有两个真音数的数字为特殊数字。\n从定义上看，特殊数字$z$一定有一个因数为1，那么其另一个真因数一定是$\\sqrt{z}$， 否则就会有加上1的三个真因数，就会导致$z$不是特殊数字，因为$z$有3个真因数 $\\sqrt{z}$一定为质数，否则$\\sqrt{z}$也会有真因数，就会影响$z$本身 区间[l,r]内的特殊数字个数，就是[0,r]特殊数字个数减去[0,l-1]特殊数字个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int MX = 31622; int pi[MX + 1]; auto init = []() { for (int i = 2; i \u0026lt;= MX; i++) { if (pi[i] == 0) { // i从2开始 i的倍数已经被标记为-1了 pi[i] = pi[i - 1] + 1; for (int j = i * i; j \u0026lt;= MX; j += i) { pi[j] = -1; } } else { pi[i] = pi[i - 1]; } } return 0; }(); class Solution { public: int nonSpecialCount(int l, int r) { return r - l + 1 - (pi[int(sqrt(r))] - pi[int(sqrt(l - 1))]); } }; 时间复杂度 $O(1)$ 空间复杂度 $O(1)$ ","permalink":"http://localhost:14745/posts/leetcode-3233/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3233"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:14745/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:14745/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:14745/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\n1 print(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:14745/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"My First Post"},{"content":"自我介绍 C++ i++ ,++i i++是右值，++i是左值 如果在一条语句内执行i++, 会先获取i的值，然后执行语句，执行结束后i自增1 如果在一条语句内执行++i, 会先对i自增1，然后执行语句 补充：一般来讲，i++ 的执行操作为：使用临时对象保存i的值，然后执行i+1，返回临时对象；++i 直接对i自增，不涉及临时变量 for-loop for(int i = 0;i\u0026lt;10;i++/++i\u0026gt;): ++i 与i++ 输出i，结果一致吗？ 一致\nfor()的使用\nfor如果使用之前声明的变量，可以直接以for (;condition;expression) 循环，循环开始时会获取变量的初始值，判断本次执行是否满足条件，满足则执行，执行完循环体，循环变量更新，不满足则结束循环 也可以使用for(init;condition;expression) 3. 其他想到的补充：\n对象初始化 回答会根据传递的参数，调用不同的重载。也可以根据成员变成，隐式构造；也可以将构造函数声明为explicit的，禁止隐式构造。 面试官问还有吗？不知道问的什么，然后继续问了虚函数。\n虚函数 成员函数，通过virtual修饰，子类继承时可以选择是否重载，也可以通过virtual 成员函数=0的方式声明为纯虚函数，子类必须重载。 子类继承父类时，构造子类时需要先构造父类，析构时通过声明父类析构为virtual，先析构子类，后析构父类。 补充：\n纯虚函数的父类为虚基类，无法实例化。 如果构造函数中包含虚函数，因为子类还没有构造，没有虚函数指针，因此会调用父类的虚函数。 虚函数，成员函数会存储在代码段，虚函数表存储在rodata段 在析构函数中调用虚函数时：基类析构函数在执行时，派生类部分的对象已经被销毁，虚函数表的指针可能不再有效，导致虚函数调用的行为不可预测。 inline 因为inline会原地展开，没有具体的地址，无法通过指针访问 static函数不能是虚函数，static成员函数是类级别的，无法通过多态调用。 子类可以访问父类的静态资源，只要子类有访问权限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; class Base { public: static int x; public: static void staticFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Base static function\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int Base::x = 30; class Derived : public Base { public: static int x; public: static void derivedStaticFunction() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived static function\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int Derived::x = 40; int main() { Base::staticFunction(); // 访问父类的静态成员函数 Derived::staticFunction(); // 子类也可以通过类名访问父类的静态成员函数 std::cout \u0026lt;\u0026lt; Base::x \u0026lt;\u0026lt; std::endl; // 访问父类的静态成员变量 std::cout \u0026lt;\u0026lt; Derived::x \u0026lt;\u0026lt; std::endl; // 访问子类的静态成员变量,同名资源 优先输出子类的 } 输出\n1 2 Base static function Base static function 虚函数指针 虚函数指针存在对象空间内，只有在调用时，才会通过虚函数指针，访问虚函数表，调用对应的虚函数。\nnew delete, malloc free C++可以视作C的超集，C++继承了C的malloc和free\nnew / delete new 动态申请内存，返回对应对象类型的指针， 调用类的构造函数，并进行初始化，访问了内存，涉及到虚实地址变换 申请失败会抛出异常std::bad_alloc。 delete 释放通过new申请的空间； 调用类的析构函数 补充：可以通过new(nothrow)返回空指针; new和delete是C++运算符可以重载。是否访问内存取决于具体的初始化逻辑，虚实地址变换由操作系统完成。 malloc / free malloc 申请内存，返回void类型的指针， 不进行初始化，因此没有访存 申请失败，返回NULL free 释放通过malloc申请的空间； 补充：malloc和free是C的函数。不支持重载 内存布局 栈： 自动管理，速度比较快，超出作用域自定析构 堆：手动管理，通过裸指针申请时，必须手动析构；也可以通过智能指针管理 全局区data：初始化的全局变量和静态变量 代码区text：代码段，存储函数，和类的静态成员函数 bss区：未初始化的全局变量和静态变量，默认为0 rodata区：只读数据，常量 线程 进程区别 进程 进程享有自己的地址空间，因此多进程之间是隔离的，一个进程的崩溃往往不会导致其他进程崩溃 进程通信比较复杂 进程是资源分配的基本单位 线程 多个线程共享一个进程的地址空间，因此一个线程崩溃有可能导致其他线程的崩溃 线程通信简单，因此需要频繁交互任务可以使用多线程。 补充：进程通信包括：管道，共享内存，消息队列，socket，信号，信号量；线程通信主要包括：互斥锁，条件变量，信号量，原子操作，互斥量，读写锁。 数据库索引 尴尬，答成引擎了。然后又回答一遍\nB+： 多路平衡，高度比较矮，快速查询，叶子节点为链表结构，支持范围查询，非叶子节点存储索引节点，叶子节点存储数据 B：不支持范围查询，非叶子节点也可以存储数据 单列索引：单个字段创建索引 联合索引：多个字段创建索引，需要主要最左匹配原则 补充：哈希索引：快速查找，无法排序，不支持范围查询， 项目 问到有没有测过并发量。回答没有，但是根据之前测试线程池的经验，应该可以支持1w用户。\n网络部分 浏览器访问url到渲染页面的具体过程 DNS解析 有缓存先查缓存 没有缓存，查询根域名服务器，根域名服务器通过树状结构查询顶级域名服务器，顶级域名查询负责该域名的权威域名服务器 权威域名服务器返回IP地址 TCP握手 IP 同一个子网，通过arp寻找对应的mac，不同子网通过默认路由转发，通过路由器自动更新下一跳的mac地址寻找目标mac地址 封装http消息，请求行，请求头，请求体， 通过交换机或路由器将信息转为二进制流，发送到目标主机 服务器收到后通过拆包，协议栈自底向上到达应用层，知道是http消息，取出对应的资源，以响应行：status_code等，响应头，响应体，经协议栈自顶向下发送 客户端收到消息，通过浏览器渲染得到页面 如何加快http的速度 选择压缩算法，压缩消息体 服务器负载均衡，返回最近的最快的服务器 选择合适的协议，因为TCP很慢，所以http3.0 使用了UDP实现的quic 将用户访问过的资源，在本地缓存 补充：其他优化方式：合并多个css、js使用一个http连接发送，减少请求数量；异步加载js；使用高效的图像压缩算法，压缩图像 补充缓存： 浏览器缓存：通过设置适当的缓存策略（如Cache-Control、Expires）在浏览器端缓存常用资源，避免每次请求都重新从服务器加载资源，显著提高页面加载速度。 CDN缓存：内容分发网络（CDN）将资源缓存到离用户更近的节点，通过地理位置分发减少网络延迟，提升响应速度。 服务器端缓存：对于常用的动态资源（如数据库查询结果），可以使用 Redis 或 Memcached 等缓存技术，减少数据库的压力，快速返回常见请求的结果。 服务工作者缓存：现代浏览器提供服务工作者（Service Workers）来缓存资源并提供离线支持，使得即使没有网络，用户也可以继续使用应用程序。 对如何成为一个优秀的开发者有什么看法 主观题。。。\n手撕 二叉树最近公共祖先 ACM模式，写出函数讲解思路\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct TreeNode{ int val; TreeNode *left; TreeNode *right; TreeNode():val(0),left(nullptr), right(nullptr){} TreeNode(int _val):val(_val),left(nullptr), right(nullptr){} }; TreeNode * commonAncestor(TreeNode *root, TreeNode *p, TreeNode *q){ if(!root||p==root||q==root) return p; auto left = commonAncestor(root-\u0026gt;left, p, q); auto right = commonAncestor(root-\u0026gt;right, p, q); if(left\u0026amp;\u0026amp;right) return root; return left?left:right; } ","permalink":"http://localhost:14745/posts/%E5%BF%AB%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%80%E9%9D%A2/","summary":"12/09/2024 快手广告部门客户端一面","title":"快手客户端一面"},{"content":"无自我介绍 熟悉的C++版本 C++11以后的基本都了解一些， 没有特别针对某个版本.\n智能指针 shared_ptr: 支持拷贝、移动，可以作为返回值类型，避免大对象的拷贝. 引用计数是线程安全的 unique_ptr：支持移动，可以通过转移所有权的方式，将对象的所有权转移给另一个独占指针 weal_ptr: 支持拷贝，可以作为返回值类型，但是不能转移所有权，只能通过weak_ptr转成shared_ptr gdb gcc有用过吗 不怎么用gdb gcc有了解\ngcc如何预处理 忘了，回答gcc有参数控制\n1 gcc -E main.c -o main.i 如何获取不进行链接的代码 忘了，回答gcc有参数控制\n1 gcc -c main.c -o main.o 线程安全的单例模式 通过C++11std::call_once实现 对指针判空执行两次，因为第一次判断为空后初始化前，可能其他线程已经初始化了，所以要两次判空 问有没有其他的，回答原子变量应该也行，不是很了解。 了解压缩算法吗 不知道为啥问这个问题，面试官接着问是否了解哈夫曼，然后让讲一下自己了解的压缩算法。回答了科研做的图像压缩。\n项目 项目结构 略\n负载均衡怎么做的 通过roundRobin方式实现，返回一个连接数量少的服务器；接着问道有考虑延迟吗，回答没有，因为是在单个机器测试的。\n单例模板基类是什么 通过模板类是实现一个单例基类，子类通过CRTP的方式实现单例。\nQt键盘鼠标事件 键盘事件：keyPressEvent keyReleaseEvent 鼠标事件：mousePressEvent mouseReleaseEvent mouseMoveEvent linux相关 docker如何建立目录映射 回答，在创建容器时通过-v指定宿主目录和容器目录的映射关系。\ntop如何根据内存占用排序 回答不知道，自己使用的基于top封装的btop，可以通过命令控制\n1 top -o %MEM 如何查找进程的句柄， 回答不太了解。可以使用ps命令查询进程状态。 查询大模型得到： 进程句柄：操作系统为每个进程分配的一个唯一标识符。它主要用于操作系统内核和其他系统组件之间进行进程管理和通信。以下是关于进程句柄的一些关键点：\n1 ls -l /proc/\u0026lt;pid\u0026gt;/fd 查看进程端口占用 1 netstat -anp 查看进程打开的文件句柄 回答不知道，查询大模型得到：\n1 lsof -p \u0026lt;pid\u0026gt; git 回答稀碎，只会使用push, pull\ngit rebase git rebase可以将一个分支的更改应用到另一个分支上，可以用来\n更新分支： 将当前分支的更改应用到最新的主分支（如 main 或 master）上，以保持代码的最新状态。 例如，如果你在一个功能分支上工作，而主分支上有新的提交，你可以使用 rebase 将功能分支的更改应用到最新的主分支上。 线性化提交历史： rebase 可以使提交历史更加线性，避免合并提交（merge commit）的出现，从而使提交历史更清晰。 例如，如果你从 main 分支派生了一个功能分支，并且 main 分支上有新的提交，rebase 可以将你的功能分支的提交重新应用到 main 分支的最新提交之上。 解决冲突： 在 rebase 过程中，如果遇到冲突，Git 会暂停并提示你解决冲突。解决冲突后，你可以继续 rebase 过程。 例如，如果你的功能分支和 main 分支在同一个文件上进行了修改，rebase 会提示你解决这些冲突。 git 如何创建分支 回答使用checkout 具体是：\n1 git checkout -b \u0026lt;branch_name\u0026gt; ","permalink":"http://localhost:14745/posts/%E9%87%91%E5%B1%B1%E4%BA%8C%E9%9D%A2/","summary":"12/05/2024 金山wpsC++二面","title":"金山二面"},{"content":"自我介绍：略 经常使用的容器 map k,v可以存储操作id和函数，作为回调。\nsort()使用了哪种排序算法 sort() 底部使用了多种排序算法： 快排，堆排\n当数据量大，分布随机时，使用快速排序 数据量小，使用插入排序 递归深度过深时使用堆排序 排序算法的使用场景 快排：无序数组效率会很高，但是有序数组效率会很低，所以快速排序只适用于无序数组。 归并排序：内存有限的情况下，可以使用多路归并 插入排序： 基本有序的数据，适合用插入排序。 智能指针 weak_ptr可以提升为shared_ptr吗？ 可以。\nshared_ptr: 会使用计数器来记录引用次数，当引用次数为0时，释放对象。 weak_ptr：weak_ptr实现弱引用，可以通过.lock() 提升为 shared_ptr 使用一段代码体现C++面向对象的思想 首先，C++面向对象的特性有三个\n封装 继承 多态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Base{ public: Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base constructoer\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void getObjName() { std::cout \u0026lt;\u0026lt; \u0026#34;This is a Base object\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Base() { std::cout \u0026lt;\u0026lt; \u0026#34;Base destructor\u0026#34; \u0026lt;\u0026lt; std::endl; } }; class Derived:public Base{ public: Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived constructoer\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual void getObjName() override { std::cout \u0026lt;\u0026lt; \u0026#34;This is a Derived object\u0026#34; \u0026lt;\u0026lt; std::endl; } virtual ~Derived() { std::cout \u0026lt;\u0026lt; \u0026#34;Derived destructor\u0026#34; \u0026lt;\u0026lt; std::endl; } }; int main() { Base *p = new Derived(); p-\u0026gt;getObjName(); delete p; } 这段代码会输出:\n1 2 3 4 5 Base constructoer Derived constructoer This is a Derived object Derived destructor Base destructor 面试官接着问了两个类的大小， 回答没有考虑继承时的虚函数指针，所以回答的两个都是1。 实际上因为对象会有一个虚函数指针，对于个一个64位的机器，指针的大小是8字节，所以两个类的大小都是8字节。\n1 std::cout \u0026lt;\u0026lt; sizeof(Base) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; sizeof(Derived) \u0026lt;\u0026lt; std::endl; 输出\n1 8 8 实现字符串数字相加，相减 当时实现时考虑的场景太多了，所以没有实现。 而且要注意，做相加或相减时，要将字符转为整数。 所以具体实现时，要考虑\n实现基础的 正数相加 大数减小数 特殊情况，特殊判定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 // 1. 首先要将两个字符串的前缀0 去掉 std::string trimLeadingZeors(const std::string \u0026amp;str) { size_t nonZeroIdx = str.find_first_not_of(\u0026#39;0\u0026#39;); if(nonZeroIdx == std::string::npos) return \u0026#39;0\u0026#39;; // 此时全部是0 return str.substr(nonZeroIdx); } // 2. 比较两个字符串数字绝对值的大小 bool isAbsGreaterOrEqual(const std::string \u0026amp;a, const std::string \u0026amp;b) { std::string aTrimmed = trimLeadingZeors(a); std::string bTrimmed = trimLeadingZeors(b); if(aTrimmed.size() != bTrimmed.size()) return aTrimmed.size() \u0026gt; bTrimmed.size(); return aTrimmed \u0026gt; bTrimmed; } // 3. 两个整数字符串加法 std::string addStrings(const std::string \u0026amp;a, const std::string \u0026amp;b) { std::string result; int carry = 0, sum=0; int i = a.size()-1, j = b.size()-1; while(i\u0026gt;=0 || j\u0026gt;=0 || carry) { int digitA = (i\u0026gt;=0)?a[i--]-\u0026#39;0\u0026#39;:0; int digitB = (j\u0026gt;=0)?b[i--]-\u0026#39;0\u0026#39;:0; sum = digitA + digitB + carry; carry = sum / 10; result.push_back(sum % 10 + \u0026#39;0\u0026#39;); } std::reverse(result.begin(), result.end()); return result; } // 4. 字符串减法， a\u0026gt;=b std::string subStrings(const std::string \u0026amp;a, const std::string \u0026amp;b) { std::string result; int borrow = 0, diff=0; int i = a.size()-1, j = b.size()-1; while(i\u0026gt;=0 || j\u0026gt;=0) { int digitA = (i\u0026gt;=0)?a[i--]-\u0026#39;0\u0026#39;:0; int digitB = (j\u0026gt;=0)?b[i--]-\u0026#39;0\u0026#39;:0; diff = digitA - digitB - borrow; if(diff \u0026lt; 0) { diff += 10; borrow = 1; }else { borrow = 0; } result.push_back(diff + \u0026#39;0\u0026#39;); } std::reverse(result.begin(), result.end()); return result; } // 5. 实现 任意类型的加减 std::string add(const std::string \u0026amp;num1, const std::string \u0026amp;num2) { bool isNum1Negative = (num1[0] == \u0026#39;-\u0026#39;); bool isNum2Negative = (num2[0] == \u0026#39;-\u0026#39;); std::string absNum1 = isNum1Negative ? num1.substr(1) : num1; std::string absNum2 = isNum2Negative ? num2.substr(1) : num2; if (!isNum1Negative \u0026amp;\u0026amp; !isNum2Negative) { // 都是正数 return addStrings(absNum1, absNum2); } else if (isNum1Negative \u0026amp;\u0026amp; isNum2Negative) { // 都是负数 return \u0026#34;-\u0026#34; + addStrings(absNum1, absNum2); } else if (isNum1Negative) { // num1负，num2正 if (isAbsGreaterOrEqual(absNum1, absNum2)) { return \u0026#34;-\u0026#34; + subtractStrings(absNum1, absNum2); } else { return subtractStrings(absNum2, absNum1); } } else { // num1正，num2负 if (isAbsGreaterOrEqual(absNum2, absNum1)) { return \u0026#34;-\u0026#34; + subtractStrings(absNum2, absNum1); } else { return subtractStrings(absNum1, absNum2); } } } // 字符串相减 任意 std::string subtract(const std::string \u0026amp;num1, const std::string \u0026amp;num2) { std::string negatedNum2 = (num2[0] == \u0026#39;-\u0026#39;) ? num2.substr(1) : \u0026#34;-\u0026#34; + num2; return add(num1, negatedNum2); } 最后 倒霉倒霉倒霉。面试期间，快手电话没接到，应该是约面的。结束之后去官网看已经挂了。此前快手三面因为面试官的问题有一个是特定场景，跟C++不一样没有答出来。讲解项目面试官说他没听懂😅。\n","permalink":"http://localhost:14745/posts/%E9%87%91%E5%B1%B1%E4%B8%80%E9%9D%A2/","summary":"12/03/2024 金山wpsC++一面","title":"金山一面"},{"content":"原题\nleetcode 3274 检查棋盘方格颜色是否相同 方法1 因为原题给出了棋盘的格式，所以我的想法是初始化棋盘，然后根据两个坐标访问即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { private: const string s1 = \u0026#34;01010101\u0026#34;; const string s2 = \u0026#34;10101010\u0026#34;; vector\u0026lt;string\u0026gt; grid; void init() { grid.resize(8, string(8, \u0026#39;0\u0026#39;)); for (int i = 0; i \u0026lt; 8; i++) { grid[i] = i % 2 ? s1 : s2; } } public: bool checkTwoChessboards(string coordinate1, string coordinate2) { init(); return grid[coordinate1[0] - \u0026#39;a\u0026#39;][coordinate1[1] - \u0026#39;0\u0026#39; - 1] == grid[coordinate2[0] - \u0026#39;a\u0026#39;][coordinate2[1] - \u0026#39;0\u0026#39; - 1]; } }; 时间复杂度 使用了常数时间初始化棋盘，可以视作O(1) 空间复杂度 使用了常数量的空间存储棋盘，可以视作 O(1) 方法2 方法2 就很取巧了。棋盘的横坐标是a~h ascii即为97~104，纵坐标为1~8。 举几个例子：\n(a,1)为黑色，(a,2)为白色，后边交替\u0026hellip;\u0026hellip; (b,1)为白色，(b,2)为黑色，后边交替\u0026hellip;\u0026hellip; (c,1)为黑色，(c,2)为白色，后边交替\u0026hellip;\u0026hellip; (d,1)为白色，(d,2)为黑色，后边交替\u0026hellip;\u0026hellip; 把横坐标使用ascii代替后 (97,1)为黑色，(97,2)为白色，后边交替\u0026hellip;\u0026hellip; (98,1)为白色，(98,2)为黑色，后边交替\u0026hellip;\u0026hellip; (99,1)为黑色，(99,2)为白色，后边交替\u0026hellip;\u0026hellip; (100,1)为白色，(100,2)为黑色，后边交替\u0026hellip;\u0026hellip; 总结规律： 如果横纵坐标奇偶性一致，为黑色，否则为白色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { bool same(int a, int b) { if (a % 2 \u0026amp;\u0026amp; b % 2) return true; else if (a % 2 == 0 \u0026amp;\u0026amp; b % 2 == 0) return true; return false; } public: bool checkTwoChessboards(string s, string t) { int s0 = toascii(s[0]); int s1 = s[1] - \u0026#39;0\u0026#39;; int t0 = toascii(t[0]); int t1 = t[1] - \u0026#39;0\u0026#39;; if (same(s0, s1) \u0026amp;\u0026amp; same(t0, t1) || !same(s0, s1) \u0026amp;\u0026amp; !same(t0, t1)) return true; return false; } }; 时间复杂度 O(1) 空间复杂度 O(1) ","permalink":"http://localhost:14745/posts/leetcode-3274-12-03-2024/","summary":"leetcode 3274 简单题，但是原理不简单","title":"Leetcode 3274 12/03/2024"},{"content":"std::async 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;chrono\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; // async 获取异步返回值 std::string fetchDataFromDB(std::string query) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is fetching data from DB...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); return \u0026#34;Data: \u0026#34; + query; } void use_async() { // 异步获取数据 std::future\u0026lt;std::string\u0026gt; fetchedData = std::async(std::launch::async, fetchDataFromDB, \u0026#34;query\u0026#34;); // 主线程正常进行 for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } // get() 是阻塞的， 只有数据返回后才会继续执行 std::string data = fetchedData.get(); std::cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; } int main() { use_async(); return 0; } async 的启动模式 std::launch::async 立即执行 std::launch::defer 调用std::future::get时才会执行 std::launch::deferred|std::launch::async 不同的环境执行结果不同 std::future std::future::get 调用时会阻塞，调用后std::future就会失效 std::future::wait 阻塞调用，如果任务完成就会返回，没有则继续等待，可以多次调用，但是一旦调用了std::future::get 因为对象std::future的失效，就会异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 std::string fetchDataFromDB(std::string query) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is fetching data from DB...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); return \u0026#34;Data: \u0026#34; + query; } void use_async_future_wait() { // 异步获取数据 std::future\u0026lt;std::string\u0026gt; fetchedData = std::async(std::launch::async, fetchDataFromDB, \u0026#34;query\u0026#34;); // 主线程正常进行 for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } // get() 是阻塞的， 只有数据返回后才会继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;first call `fetchedData.get()` \u0026#34; \u0026lt;\u0026lt; std::endl; fetchedData.wait(); // std::string data = fetchedData.get(); // std::cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; for (int i = 10; i \u0026lt; 20; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;call `future::wait()` again \u0026#34; \u0026lt;\u0026lt; std::endl; fetchedData.wait(); } std::packaged_task std::packaged_task可以将异步任务包装成std::future，运行在另一个线程上，可以捕获任务的返回值或异常 使用：\n创建一个std::packaged_task 对象，包装一个任务 调用std::packaged_task::get_future 获取一个std::future对象 在另一个线程上调用std::packaged_task的operator()执行任务 调用std::future::get获取返回值或异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int my_task() { std::this_thread::sleep_for(std::chrono::seconds(4)); std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is running task...\u0026#34; \u0026lt;\u0026lt; std::endl; return 42; } void use_packaged_task() { std::packaged_task\u0026lt;int()\u0026gt; task(my_task); for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;Call `task.get_future()`\u0026#34; \u0026lt;\u0026lt; std::endl; auto res = task.get_future(); std::cout \u0026lt;\u0026lt; \u0026#34;Get result from `my_task()`\u0026#34; \u0026lt;\u0026lt; std::endl; // 需要开辟一个子线程处理`std::packaged_task` 必须使用`std::move` std::packaged_task只支持移动语义 std::thread t(std::move(task)); t.detach(); std::cout \u0026lt;\u0026lt; res.get(); } std::promise std::promise也可以在线程中获取异步返回值，保存在std::future中，在另外一个线程中获取这个值或异常。\n与std::packaged_task不同的是，std::packaged_task绑定的是一个函数，也就是只有等待函数执行完才能拿到结果，\n而std::promise 可以在函数中的任意一步定义，拿到值之后可以直接在其他线程中得到值。\nstd::promise也是只支持移动操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 void set_value(std::promise\u0026lt;int\u0026gt; prom) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is setting value...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); prom.set_value(42); std::cout \u0026lt;\u0026lt; \u0026#34;promise has set value to 42\u0026#34; \u0026lt;\u0026lt; std::endl; } void use_promise() { std::promise\u0026lt;int\u0026gt; prom; std::future\u0026lt;int\u0026gt; fut = prom.get_future(); std::thread t(set_value, std::move(prom)); // 开辟的子线程会运行，但只有通过`std::future`对象才能获取到`std::promise`中的值 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else...\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for subthread to set value \u0026#34;\u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;get value for subthread: \u0026#34; \u0026lt;\u0026lt; fut.get() \u0026lt;\u0026lt; std::endl; t.join(); } // 使用promise 捕获异常 void promise_one_exception(std::promise\u0026lt;void\u0026gt; promise) { try { throw std::runtime_error(\u0026#34;Oops, Error\u0026#34;); } catch (...) { promise.set_exception(std::current_exception()); } } void use_promise_exception() { std::promise\u0026lt;void\u0026gt; promise; std::future\u0026lt;void\u0026gt; future = promise.get_future(); std::thread t(promise_one_exception, std::move(promise)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else...\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for subthread to set value \u0026#34; \u0026lt;\u0026lt; std::endl; future.wait(); try { future.get(); } catch (std::exception \u0026amp;e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } t.join(); } // 搭配std::shared_future void function(std::promise\u0026lt;int\u0026gt; \u0026amp;\u0026amp;prom) { std::this_thread::sleep_for(std::chrono::seconds(10)); prom.set_value(10); } void threadfunction(std::shared_future\u0026lt;int\u0026gt; future) { try { int result = future.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } catch (std::future_error \u0026amp;e) { std::cout \u0026lt;\u0026lt; \u0026#34;future error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } void use_shared_future() { std::promise\u0026lt;int\u0026gt; prom; std::shared_future\u0026lt;int\u0026gt; future = prom.get_future(); std::thread t1(function, std::move(prom)); std::thread t2(threadfunction, future); // 不可以通过 std::move(future)的方式传递 std::thread t3(threadfunction, future); t1.join(), t2.join(), t3.join(); } last but not least C++线程池的一种实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \u0026lt;condition_variable\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; class ThreadPool { using TASK = std::packaged_task\u0026lt;void()\u0026gt;; private: static std::shared_ptr\u0026lt;ThreadPool\u0026gt; _instance; std::atomic\u0026lt;int\u0026gt; _thread_count; std::atomic\u0026lt;bool\u0026gt; _stop; std::mutex _mtx; std::condition_variable _cond; std::vector\u0026lt;std::thread\u0026gt; _workers; std::queue\u0026lt;TASK\u0026gt; _tasks; private: void work_thread() { while (!this-\u0026gt;_stop.load()) { TASK task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(this-\u0026gt;_mtx); this-\u0026gt;_cond.wait(lock, [this] { return this-\u0026gt;_stop.load() || !this-\u0026gt;_tasks.empty(); }); if (this-\u0026gt;_tasks.empty()) return; task = std::move(this-\u0026gt;_tasks.front()); this-\u0026gt;_tasks.pop(); } this-\u0026gt;_thread_count--; task(); this-\u0026gt;_thread_count++; } } void start() { for (int i = 0; i \u0026lt; _thread_count; ++i) { _workers.emplace_back(\u0026amp;ThreadPool::work_thread, this); } } void stop() { _stop.store(true); _cond.notify_all(); for (auto \u0026amp;t : _workers) { if (t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Join thread with id = \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; std::endl; t.join(); } } } ThreadPool(size_t thread_count = 4) : _stop(false) { if (thread_count \u0026lt;= 1) _thread_count = 1; else _thread_count = thread_count; start(); } ThreadPool(const ThreadPool \u0026amp;other) = delete; ThreadPool \u0026amp;operator=(const ThreadPool \u0026amp;) = delete; public: ~ThreadPool() { stop(); } static std::shared_ptr\u0026lt;ThreadPool\u0026gt; GetInstance() { std::once_flag s_flag; std::call_once(s_flag, [\u0026amp;]() { if (_instance == nullptr) _instance = std::shared_ptr\u0026lt;ThreadPool\u0026gt;(new ThreadPool(4)); }); return _instance; } template \u0026lt;class F, class... Args\u0026gt; auto commit(F \u0026amp;\u0026amp;f, Args \u0026amp;\u0026amp;...args) -\u0026gt; std::future\u0026lt;decltype(f(args...))\u0026gt; { using RETURN_TYPE = decltype(f(args...)); if (_stop.load()) return std::future\u0026lt;RETURN_TYPE\u0026gt;{}; auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;RETURN_TYPE()\u0026gt;\u0026gt;( std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...)); std::future\u0026lt;RETURN_TYPE\u0026gt; res = task-\u0026gt;get_future(); { std::unique_lock\u0026lt;std::mutex\u0026gt; lck(_mtx); _tasks.emplace([task]() { (*task)(); }); } _cond.notify_one(); return res; } auto available_threads() const { return _thread_count.load(); } }; std::shared_ptr\u0026lt;ThreadPool\u0026gt; ThreadPool::_instance = nullptr; int main() { auto res = ThreadPool::GetInstance()-\u0026gt;commit( [](int a, int b) { return a + b; }, 10, 20); std::cout \u0026lt;\u0026lt; res.get() \u0026lt;\u0026lt; std::endl; }; 注意,在GetInstance()中，只能使用std::shared_ptr\u0026lt;ThreadPool\u0026gt;(new ThreadPool);的方式构造 因为make_shared无法访问私有构造函数。\n","permalink":"http://localhost:14745/posts/future-async-promise/","summary":"C++中std::future, std::packaged_task, std::promise的使用","title":"Future Async Promise"},{"content":"多线程 多线程享有一个进程的地址空间，线程切换比进程切换要简单，而且线程通信也比进程通信要简单。\nC++中使用多线程可以通过std::thread类实现。std::thread位于头文件\u0026lt;thread\u0026gt;中。 具体可以通过以下方式实现一个线程\n绑定普通函数 绑定lambda表达式 绑定函数对象 函数指针 仿函数 std::bind 初始化一个线程后，线程就会开始执行，但是线程可能会在主线程结束之后还需要运行，因此需要使用std::thread::join方法来等待线程结束。\n也可以通过std::thread::detach在主线程后台运行，主线程不会等待子线程执行结束。 绑定普通函数 1 2 3 4 5 6 7 8 9 void print() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; } void bindaThread() { std::thread t1(print); t1.join(); } 绑定类成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 class Foo { public: void print(){ std::cout \u0026lt;\u0026lt; \u0026#34;This is a class member function\u0026#34; \u0026lt;\u0026lt; std::endl; } } void bindClassMember() { Foo foo; std::thread t(\u0026amp;Foo::print, \u0026amp;foo); t.join(); } 绑定lambda 1 2 3 4 5 6 void bindLambda() { std::thread t([](){ std::cout \u0026lt;\u0026lt; \u0026#34;Bind a lambda function\u0026#34; \u0026lt;\u0026lt; std::endl; }) } 绑定仿函数 1 2 3 4 5 6 7 8 9 10 11 12 struct ClassLikeFunc { void operator()() { std::cout \u0026lt;\u0026lt; \u0026#34;Bind a class like function\u0026#34; \u0026lt;\u0026lt; std::endl; } } void bindClassLikeFunc() { std::thread t{ClassLikeFunc()}; t.join(); } 如需要传参，初始化时std::thread t(func,params)即可。\n注意 std::thread不支持拷贝构造，只能通过移动构造。 因此一个线程对象可以通过std::move()的方式将所有权转移给其他线程 std::thread默认传参是以拷贝的方式，如果要传入引用，需要通过std::ref() ","permalink":"http://localhost:14745/posts/cpp-thread-basic/","summary":"C++多线程的基础概念","title":"Cpp Thread Basic"},{"content":"leetcode 743 原题\n分析 题目要求计算从起始节点到所有节点的最短时间，也就是到最远距离的最小时间。 使用dijkstra算法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: int networkDelayTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; times, int n, int k) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(n, INT_MAX / 2));// 定义图， g[i][j] for (auto\u0026amp; t : times) { g[t[0] - 1][t[1] - 1] = t[2]; } vector\u0026lt;int\u0026gt; dis(n, INT_MAX / 2), done(n); // dis[i] 表示k-\u0026gt; i的最短路 dis[k - 1] = 0; // 起始节点为k 起始距离为0 while (true) { int x = -1; for (int i = 0; i \u0026lt; n; i++) { // 遍历dis 寻找距离最短的点 if (!done[i] \u0026amp;\u0026amp; (x \u0026lt; 0 || dis[i] \u0026lt; dis[x])) { x = i; } } // 如果 没有找到未处理的点，直接返回 if (x \u0026lt; 0) return ranges::max(dis); // 如果找到的距离最小的点的距离还是inf 返回-1，表示不可达 if (dis[x] == INT_MAX / 2) return -1; done[x] = true; // 更新该节点为访问过 for (int y = 0; y \u0026lt; n; y++) { dis[y] = min(dis[y], dis[x] + g[x][y]); // 以当前节点为起始节点，更新最小距离 } } } }; 时间复杂度 初始化邻接矩阵为$O(n^2)$ 空间复杂度 使用了邻接矩阵存储图为$O(n^2)$ ","permalink":"http://localhost:14745/posts/leetcode-743/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 743"},{"content":"leetcode 3238 原题\n分析 题目定义玩家的某个颜色的球的个数大于玩家id为胜利玩家，\n因此需要统计每个玩家的对应颜色的球的数量，也就是要定义一个二维数组 $arr[playerId][ballColor]$ 表示玩家id为playerId，球颜色为ballColor的球数量。 一个玩家只能被记录一次胜利玩家，因此需要一个标记数组$tags[playerCount]$标记玩家是否已经被记录过 一旦某个玩家的$arr[playerId][ballColor]\u0026gt;playerId$，胜利玩家结果数量+1，且要将$tags[playerId]$标记为true，表示该玩家已经被记录为胜利玩家 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 1. // const int MXN =20; // int arr[MXN][11]{0}; // bool tags[MXN]{false}; class Solution { public: int winningPlayerCount(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pick) { // 2. vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; arr(n,vector\u0026lt;int\u0026gt;(11,0)); vector\u0026lt;bool\u0026gt; tags(n,false); int result = 0; for (auto pic : pick) { // playerId = pic[0]; // ballColor = pic[1]; // tags[playerId]未被记入结果时，且arr[playerId][ballColor]\u0026gt;playerId // 结果+1 将tags[playerId] 标记为true int playerId = pic[0]; int ballColor = pic[1]; ++arr[playerId][ballColor]; if (tags[playerId] == false \u0026amp;\u0026amp; arr[playerId][ballColor] \u0026gt; playerId) { result++; tags[playerId] = true; } } return result; } }; 时间复杂度 对于每个pic 都需要遍历一次 对于两个数组，需要对$n*max(y)$的数组初始化 因此时间复杂度为$O(n*max(y)+m)$ $m$为pick的长度，$n$为playerId的数量，$y$为球颜色数量 空间复杂度 需要两个数组，因此空间复杂度为$O(n*y)$\n一些问题 尚未搞明白，为什么注释1的定义方式本地可以通过leetcode无法通过，注释2的可以\n","permalink":"http://localhost:14745/posts/leetcode-3238/","summary":"Leetcode 3238 每日一题 简单题","title":"Leetcode 3238"},{"content":"原题\nleetcode 3233 真因数：对于一个数字x x除了x本身以外的所有正因数为其真因数 特殊数字的定义为：仅有两个真音数的数字为特殊数字。\n从定义上看，特殊数字$z$一定有一个因数为1，那么其另一个真因数一定是$\\sqrt{z}$， 否则就会有加上1的三个真因数，就会导致$z$不是特殊数字，因为$z$有3个真因数 $\\sqrt{z}$一定为质数，否则$\\sqrt{z}$也会有真因数，就会影响$z$本身 区间[l,r]内的特殊数字个数，就是[0,r]特殊数字个数减去[0,l-1]特殊数字个数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const int MX = 31622; int pi[MX + 1]; auto init = []() { for (int i = 2; i \u0026lt;= MX; i++) { if (pi[i] == 0) { // i从2开始 i的倍数已经被标记为-1了 pi[i] = pi[i - 1] + 1; for (int j = i * i; j \u0026lt;= MX; j += i) { pi[j] = -1; } } else { pi[i] = pi[i - 1]; } } return 0; }(); class Solution { public: int nonSpecialCount(int l, int r) { return r - l + 1 - (pi[int(sqrt(r))] - pi[int(sqrt(l - 1))]); } }; 时间复杂度 $O(1)$ 空间复杂度 $O(1)$ ","permalink":"http://localhost:14745/posts/leetcode-3233/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3233"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:14745/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:14745/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:14745/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\n1 print(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:14745/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"My First Post"}]