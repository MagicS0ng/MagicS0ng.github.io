[{"content":"leetcode 743 原题\n分析 题目要求计算从起始节点到所有节点的最短时间，也就是到最远距离的最小时间。 使用dijkstra算法即可。\nclass Solution { public: int networkDelayTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; times, int n, int k) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(n, INT_MAX / 2));// 定义图， g[i][j] for (auto\u0026amp; t : times) { g[t[0] - 1][t[1] - 1] = t[2]; } vector\u0026lt;int\u0026gt; dis(n, INT_MAX / 2), done(n); // dis[i] 表示k-\u0026gt; i的最短路 dis[k - 1] = 0; // 起始节点为k 起始距离为0 while (true) { int x = -1; for (int i = 0; i \u0026lt; n; i++) { if (!done[i] \u0026amp;\u0026amp; (x \u0026lt; 0 || dis[i] \u0026lt; dis[x])) { x = i; // 寻找一个未访问的点，且到它的距离最小 } } if (x \u0026lt; 0) return ranges::max(dis); if (dis[x] == INT_MAX / 2) // 如果一个点不可达 直接返回 return -1; done[x] = true; // 更新该点访问过 for (int y = 0; y \u0026lt; n; y++) { dis[y] = min(dis[y], dis[x] + g[x][y]); //更新最短距离 } } } }; 时间复杂度 初始化邻接矩阵为$O(n^2)$ 空间复杂度 使用了邻接矩阵存储图为$O(n^2)$ ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-743/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 743"},{"content":"leetcode 3238 原题\n分析 题目定义玩家的某个颜色的球的个数大于玩家id为胜利玩家，\n因此需要统计每个玩家的对应颜色的球的数量，也就是要定义一个二维数组 $arr[playerId][ballColor]$ 表示玩家id为playerId，球颜色为ballColor的球数量。 一个玩家只能被记录一次胜利玩家，因此需要一个标记数组$tags[playerCount]$标记玩家是否已经被记录过 一旦某个玩家的$arr[playerId][ballColor]\u0026gt;playerId$，胜利玩家结果数量+1，且要将$tags[playerId]$标记为true，表示该玩家已经被记录为胜利玩家 // 1. // const int MXN =20; // int arr[MXN][11]{0}; // bool tags[MXN]{false}; class Solution { public: int winningPlayerCount(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pick) { // 2. vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; arr(n,vector\u0026lt;int\u0026gt;(11,0)); vector\u0026lt;bool\u0026gt; tags(n,false); int result = 0; for (auto pic : pick) { // playerId = pic[0]; // ballColor = pic[1]; // tags[playerId]未被记入结果时，且arr[playerId][ballColor]\u0026gt;playerId // 结果+1 将tags[playerId] 标记为true int playerId = pic[0]; int ballColor = pic[1]; ++arr[playerId][ballColor]; if (tags[playerId] == false \u0026amp;\u0026amp; arr[playerId][ballColor] \u0026gt; playerId) { result++; tags[playerId] = true; } } return result; } }; 时间复杂度 对于每个pic 都需要遍历一次 对于两个数组，需要对$n*max(y)$的数组初始化 因此时间复杂度为$O(n*max(y)+m)$ $m$为pick的长度，$n$为playerId的数量，$y$为球颜色数量 空间复杂度 需要两个数组，因此空间复杂度为$O(n*y)$\n一些问题 尚未搞明白，为什么注释1的定义方式本地可以通过leetcode无法通过，注释2的可以\n","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3238/","summary":"Leetcode 3238 每日一题 简单题","title":"Leetcode 3238"},{"content":"原题\nleetcode 3233 真因数：对于一个数字x x除了x本身以外的所有正因数为其真因数 特殊数字的定义为：仅有两个真音数的数字为特殊数字。\n从定义上看，特殊数字$z$一定有一个因数为1，那么其另一个真因数一定是$\\sqrt{z}$， 否则就会有加上1的三个真因数，就会导致$z$不是特殊数字，因为$z$有3个真因数 $\\sqrt{z}$一定为质数，否则$\\sqrt{z}$也会有真因数，就会影响$z$本身 区间[l,r]内的特殊数字个数，就是[0,r]特殊数字个数减去[0,l-1]特殊数字个数 const int MX = 31622; int pi[MX + 1]; auto init = []() { for (int i = 2; i \u0026lt;= MX; i++) { if (pi[i] == 0) { // i从2开始 i的倍数已经被标记为-1了 pi[i] = pi[i - 1] + 1; for (int j = i * i; j \u0026lt;= MX; j += i) { pi[j] = -1; } } else { pi[i] = pi[i - 1]; } } return 0; }(); class Solution { public: int nonSpecialCount(int l, int r) { return r - l + 1 - (pi[int(sqrt(r))] - pi[int(sqrt(l - 1))]); } }; 时间复杂度 $O(1)$ 空间复杂度 $O(1)$ ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3233/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3233"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"https://magics0ng-github-io.pages.dev/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"}]