[{"content":"std::async #include \u0026lt;chrono\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;thread\u0026gt; // async 获取异步返回值 std::string fetchDataFromDB(std::string query) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is fetching data from DB...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); return \u0026#34;Data: \u0026#34; + query; } void use_async() { // 异步获取数据 std::future\u0026lt;std::string\u0026gt; fetchedData = std::async(std::launch::async, fetchDataFromDB, \u0026#34;query\u0026#34;); // 主线程正常进行 for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } // get() 是阻塞的， 只有数据返回后才会继续执行 std::string data = fetchedData.get(); std::cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; } int main() { use_async(); return 0; } async 的启动模式 std::launch::async 立即执行 std::launch::defer 调用std::future::get时才会执行 std::launch::deferred|std::launch::async 不同的环境执行结果不同 std::future std::future::get 调用时会阻塞，调用后std::future就会失效 std::future::wait 阻塞调用，如果任务完成就会返回，没有则继续等待，可以多次调用，但是一旦调用了std::future::get 因为对象std::future的失效，就会异常 std::string fetchDataFromDB(std::string query) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is fetching data from DB...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); return \u0026#34;Data: \u0026#34; + query; } void use_async_future_wait() { // 异步获取数据 std::future\u0026lt;std::string\u0026gt; fetchedData = std::async(std::launch::async, fetchDataFromDB, \u0026#34;query\u0026#34;); // 主线程正常进行 for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } // get() 是阻塞的， 只有数据返回后才会继续执行 std::cout \u0026lt;\u0026lt; \u0026#34;first call `fetchedData.get()` \u0026#34; \u0026lt;\u0026lt; std::endl; fetchedData.wait(); // std::string data = fetchedData.get(); // std::cout \u0026lt;\u0026lt; data \u0026lt;\u0026lt; std::endl; for (int i = 10; i \u0026lt; 20; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;call `future::wait()` again \u0026#34; \u0026lt;\u0026lt; std::endl; fetchedData.wait(); } std::packaged_task std::packaged_task可以将异步任务包装成std::future，运行在另一个线程上，可以捕获任务的返回值或异常 使用：\n创建一个std::packaged_task 对象，包装一个任务 调用std::packaged_task::get_future 获取一个std::future对象 在另一个线程上调用std::packaged_task的operator()执行任务 调用std::future::get获取返回值或异常 int my_task() { std::this_thread::sleep_for(std::chrono::seconds(4)); std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is running task...\u0026#34; \u0026lt;\u0026lt; std::endl; return 42; } void use_packaged_task() { std::packaged_task\u0026lt;int()\u0026gt; task(my_task); for (int i = 0; i \u0026lt; 10; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else x\u0026#34; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026#34; time(s).\u0026#34; \u0026lt;\u0026lt; std::endl; } std::cout \u0026lt;\u0026lt; \u0026#34;Call `task.get_future()`\u0026#34; \u0026lt;\u0026lt; std::endl; auto res = task.get_future(); std::cout \u0026lt;\u0026lt; \u0026#34;Get result from `my_task()`\u0026#34; \u0026lt;\u0026lt; std::endl; // 需要开辟一个子线程处理`std::packaged_task` 必须使用`std::move` std::packaged_task只支持移动语义 std::thread t(std::move(task)); t.detach(); std::cout \u0026lt;\u0026lt; res.get(); } std::promise std::promise也可以在线程中获取异步返回值，保存在std::future中，在另外一个线程中获取这个值或异常。\n与std::packaged_task不同的是，std::packaged_task绑定的是一个函数，也就是只有等待函数执行完才能拿到结果，\n而std::promise 可以在函数中的任意一步定义，拿到值之后可以直接在其他线程中得到值。\nstd::promise也是只支持移动操作。\nvoid set_value(std::promise\u0026lt;int\u0026gt; prom) { std::cout \u0026lt;\u0026lt; \u0026#34;Subthread suspended is setting value...\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(4)); prom.set_value(42); std::cout \u0026lt;\u0026lt; \u0026#34;promise has set value to 42\u0026#34; \u0026lt;\u0026lt; std::endl; } void use_promise() { std::promise\u0026lt;int\u0026gt; prom; std::future\u0026lt;int\u0026gt; fut = prom.get_future(); std::thread t(set_value, std::move(prom)); // 开辟的子线程会运行，但只有通过`std::future`对象才能获取到`std::promise`中的值 std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else...\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for subthread to set value \u0026#34;\u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;get value for subthread: \u0026#34; \u0026lt;\u0026lt; fut.get() \u0026lt;\u0026lt; std::endl; t.join(); } // 使用promise 捕获异常 void promise_one_exception(std::promise\u0026lt;void\u0026gt; promise) { try { throw std::runtime_error(\u0026#34;Oops, Error\u0026#34;); } catch (...) { promise.set_exception(std::current_exception()); } } void use_promise_exception() { std::promise\u0026lt;void\u0026gt; promise; std::future\u0026lt;void\u0026gt; future = promise.get_future(); std::thread t(promise_one_exception, std::move(promise)); std::cout \u0026lt;\u0026lt; \u0026#34;Main thread is doing something else...\u0026#34; \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Waiting for subthread to set value \u0026#34; \u0026lt;\u0026lt; std::endl; future.wait(); try { future.get(); } catch (std::exception \u0026amp;e) { std::cout \u0026lt;\u0026lt; \u0026#34;Caught exception: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } t.join(); } // 搭配std::shared_future void function(std::promise\u0026lt;int\u0026gt; \u0026amp;\u0026amp;prom) { std::this_thread::sleep_for(std::chrono::seconds(10)); prom.set_value(10); } void threadfunction(std::shared_future\u0026lt;int\u0026gt; future) { try { int result = future.get(); std::cout \u0026lt;\u0026lt; \u0026#34;Result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; std::endl; } catch (std::future_error \u0026amp;e) { std::cout \u0026lt;\u0026lt; \u0026#34;future error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; std::endl; } } void use_shared_future() { std::promise\u0026lt;int\u0026gt; prom; std::shared_future\u0026lt;int\u0026gt; future = prom.get_future(); std::thread t1(function, std::move(prom)); std::thread t2(threadfunction, future); // 不可以通过 std::move(future)的方式传递 std::thread t3(threadfunction, future); t1.join(), t2.join(), t3.join(); } last but not least C++线程池的一种实现\n#include \u0026lt;condition_variable\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;future\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;thread\u0026gt; #include \u0026lt;utility\u0026gt; #include \u0026lt;vector\u0026gt; class ThreadPool { using TASK = std::packaged_task\u0026lt;void()\u0026gt;; private: static std::shared_ptr\u0026lt;ThreadPool\u0026gt; _instance; std::atomic\u0026lt;int\u0026gt; _thread_count; std::atomic\u0026lt;bool\u0026gt; _stop; std::mutex _mtx; std::condition_variable _cond; std::vector\u0026lt;std::thread\u0026gt; _workers; std::queue\u0026lt;TASK\u0026gt; _tasks; private: void work_thread() { while (!this-\u0026gt;_stop.load()) { TASK task; { std::unique_lock\u0026lt;std::mutex\u0026gt; lock(this-\u0026gt;_mtx); this-\u0026gt;_cond.wait(lock, [this] { return this-\u0026gt;_stop.load() || !this-\u0026gt;_tasks.empty(); }); if (this-\u0026gt;_tasks.empty()) return; task = std::move(this-\u0026gt;_tasks.front()); this-\u0026gt;_tasks.pop(); } this-\u0026gt;_thread_count--; task(); this-\u0026gt;_thread_count++; } } void start() { for (int i = 0; i \u0026lt; _thread_count; ++i) { _workers.emplace_back(\u0026amp;ThreadPool::work_thread, this); } } void stop() { _stop.store(true); _cond.notify_all(); for (auto \u0026amp;t : _workers) { if (t.joinable()) { std::cout \u0026lt;\u0026lt; \u0026#34;Join thread with id = \u0026#34; \u0026lt;\u0026lt; t.get_id() \u0026lt;\u0026lt; std::endl; t.join(); } } } ThreadPool(size_t thread_count = 4) : _stop(false) { if (thread_count \u0026lt;= 1) _thread_count = 1; else _thread_count = thread_count; start(); } ThreadPool(const ThreadPool \u0026amp;other) = delete; ThreadPool \u0026amp;operator=(const ThreadPool \u0026amp;) = delete; public: ~ThreadPool() { stop(); } static std::shared_ptr\u0026lt;ThreadPool\u0026gt; GetInstance() { std::once_flag s_flag; std::call_once(s_flag, [\u0026amp;]() { if (_instance == nullptr) _instance = std::shared_ptr\u0026lt;ThreadPool\u0026gt;(new ThreadPool(4)); }); return _instance; } template \u0026lt;class F, class... Args\u0026gt; auto commit(F \u0026amp;\u0026amp;f, Args \u0026amp;\u0026amp;...args) -\u0026gt; std::future\u0026lt;decltype(f(args...))\u0026gt; { using RETURN_TYPE = decltype(f(args...)); if (_stop.load()) return std::future\u0026lt;RETURN_TYPE\u0026gt;{}; auto task = std::make_shared\u0026lt;std::packaged_task\u0026lt;RETURN_TYPE()\u0026gt;\u0026gt;( std::bind(std::forward\u0026lt;F\u0026gt;(f), std::forward\u0026lt;Args\u0026gt;(args)...)); std::future\u0026lt;RETURN_TYPE\u0026gt; res = task-\u0026gt;get_future(); { std::unique_lock\u0026lt;std::mutex\u0026gt; lck(_mtx); _tasks.emplace([task]() { (*task)(); }); } _cond.notify_one(); return res; } auto available_threads() const { return _thread_count.load(); } }; std::shared_ptr\u0026lt;ThreadPool\u0026gt; ThreadPool::_instance = nullptr; int main() { auto res = ThreadPool::GetInstance()-\u0026gt;commit( [](int a, int b) { return a + b; }, 10, 20); std::cout \u0026lt;\u0026lt; res.get() \u0026lt;\u0026lt; std::endl; }; 注意,在GetInstance()中，只能使用std::shared_ptr\u0026lt;ThreadPool\u0026gt;(new ThreadPool);的方式构造 因为make_shared无法访问私有构造函数。\n","permalink":"https://magics0ng-github-io.pages.dev/posts/future-async-promise/","summary":"C++中std::future, std::packaged_task, std::promise的使用","title":"Future Async Promise"},{"content":"多线程 多线程享有一个进程的地址空间，线程切换比进程切换要简单，而且线程通信也比进程通信要简单。\nC++中使用多线程可以通过std::thread类实现。std::thread位于头文件\u0026lt;thread\u0026gt;中。 具体可以通过以下方式实现一个线程\n绑定普通函数 绑定lambda表达式 绑定函数对象 函数指针 仿函数 std::bind 初始化一个线程后，线程就会开始执行，但是线程可能会在主线程结束之后还需要运行，因此需要使用std::thread::join方法来等待线程结束。\n也可以通过std::thread::detach在主线程后台运行，主线程不会等待子线程执行结束。 绑定普通函数 void print() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; } void bindaThread() { std::thread t1(print); t1.join(); } 绑定类成员函数 class Foo { public: void print(){ std::cout \u0026lt;\u0026lt; \u0026#34;This is a class member function\u0026#34; \u0026lt;\u0026lt; std::endl; } } void bindClassMember() { Foo foo; std::thread t(\u0026amp;Foo::print, \u0026amp;foo); t.join(); } 绑定lambda void bindLambda() { std::thread t([](){ std::cout \u0026lt;\u0026lt; \u0026#34;Bind a lambda function\u0026#34; \u0026lt;\u0026lt; std::endl; }) } 绑定仿函数 struct ClassLikeFunc { void operator()() { std::cout \u0026lt;\u0026lt; \u0026#34;Bind a class like function\u0026#34; \u0026lt;\u0026lt; std::endl; } } void bindClassLikeFunc() { std::thread t{ClassLikeFunc()}; t.join(); } 如需要传参，初始化时std::thread t(func,params)即可。\n注意 std::thread不支持拷贝构造，只能通过移动构造。 因此一个线程对象可以通过std::move()的方式将所有权转移给其他线程 std::thread默认传参是以拷贝的方式，如果要传入引用，需要通过std::ref() ","permalink":"https://magics0ng-github-io.pages.dev/posts/cpp-thread-basic/","summary":"C++多线程的基础概念","title":"Cpp Thread Basic"},{"content":"leetcode 743 原题\n分析 题目要求计算从起始节点到所有节点的最短时间，也就是到最远距离的最小时间。 使用dijkstra算法即可。\nclass Solution { public: int networkDelayTime(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; times, int n, int k) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n, vector\u0026lt;int\u0026gt;(n, INT_MAX / 2));// 定义图， g[i][j] for (auto\u0026amp; t : times) { g[t[0] - 1][t[1] - 1] = t[2]; } vector\u0026lt;int\u0026gt; dis(n, INT_MAX / 2), done(n); // dis[i] 表示k-\u0026gt; i的最短路 dis[k - 1] = 0; // 起始节点为k 起始距离为0 while (true) { int x = -1; for (int i = 0; i \u0026lt; n; i++) { // 遍历dis 寻找距离最短的点 if (!done[i] \u0026amp;\u0026amp; (x \u0026lt; 0 || dis[i] \u0026lt; dis[x])) { x = i; } } // 如果 没有找到未处理的点，直接返回 if (x \u0026lt; 0) return ranges::max(dis); // 如果找到的距离最小的点的距离还是inf 返回-1，表示不可达 if (dis[x] == INT_MAX / 2) return -1; done[x] = true; // 更新该节点为访问过 for (int y = 0; y \u0026lt; n; y++) { dis[y] = min(dis[y], dis[x] + g[x][y]); // 以当前节点为起始节点，更新最小距离 } } } }; 时间复杂度 初始化邻接矩阵为$O(n^2)$ 空间复杂度 使用了邻接矩阵存储图为$O(n^2)$ ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-743/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 743"},{"content":"leetcode 3238 原题\n分析 题目定义玩家的某个颜色的球的个数大于玩家id为胜利玩家，\n因此需要统计每个玩家的对应颜色的球的数量，也就是要定义一个二维数组 $arr[playerId][ballColor]$ 表示玩家id为playerId，球颜色为ballColor的球数量。 一个玩家只能被记录一次胜利玩家，因此需要一个标记数组$tags[playerCount]$标记玩家是否已经被记录过 一旦某个玩家的$arr[playerId][ballColor]\u0026gt;playerId$，胜利玩家结果数量+1，且要将$tags[playerId]$标记为true，表示该玩家已经被记录为胜利玩家 // 1. // const int MXN =20; // int arr[MXN][11]{0}; // bool tags[MXN]{false}; class Solution { public: int winningPlayerCount(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; pick) { // 2. vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; arr(n,vector\u0026lt;int\u0026gt;(11,0)); vector\u0026lt;bool\u0026gt; tags(n,false); int result = 0; for (auto pic : pick) { // playerId = pic[0]; // ballColor = pic[1]; // tags[playerId]未被记入结果时，且arr[playerId][ballColor]\u0026gt;playerId // 结果+1 将tags[playerId] 标记为true int playerId = pic[0]; int ballColor = pic[1]; ++arr[playerId][ballColor]; if (tags[playerId] == false \u0026amp;\u0026amp; arr[playerId][ballColor] \u0026gt; playerId) { result++; tags[playerId] = true; } } return result; } }; 时间复杂度 对于每个pic 都需要遍历一次 对于两个数组，需要对$n*max(y)$的数组初始化 因此时间复杂度为$O(n*max(y)+m)$ $m$为pick的长度，$n$为playerId的数量，$y$为球颜色数量 空间复杂度 需要两个数组，因此空间复杂度为$O(n*y)$\n一些问题 尚未搞明白，为什么注释1的定义方式本地可以通过leetcode无法通过，注释2的可以\n","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3238/","summary":"Leetcode 3238 每日一题 简单题","title":"Leetcode 3238"},{"content":"原题\nleetcode 3233 真因数：对于一个数字x x除了x本身以外的所有正因数为其真因数 特殊数字的定义为：仅有两个真音数的数字为特殊数字。\n从定义上看，特殊数字$z$一定有一个因数为1，那么其另一个真因数一定是$\\sqrt{z}$， 否则就会有加上1的三个真因数，就会导致$z$不是特殊数字，因为$z$有3个真因数 $\\sqrt{z}$一定为质数，否则$\\sqrt{z}$也会有真因数，就会影响$z$本身 区间[l,r]内的特殊数字个数，就是[0,r]特殊数字个数减去[0,l-1]特殊数字个数 const int MX = 31622; int pi[MX + 1]; auto init = []() { for (int i = 2; i \u0026lt;= MX; i++) { if (pi[i] == 0) { // i从2开始 i的倍数已经被标记为-1了 pi[i] = pi[i - 1] + 1; for (int j = i * i; j \u0026lt;= MX; j += i) { pi[j] = -1; } } else { pi[i] = pi[i - 1]; } } return 0; }(); class Solution { public: int nonSpecialCount(int l, int r) { return r - l + 1 - (pi[int(sqrt(r))] - pi[int(sqrt(l - 1))]); } }; 时间复杂度 $O(1)$ 空间复杂度 $O(1)$ ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3233/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3233"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"https://magics0ng-github-io.pages.dev/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"https://magics0ng-github-io.pages.dev/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"}]