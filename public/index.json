[{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求\n$$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求\n$$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求\n$$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求\n$$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求\n$$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求\n$$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求 $ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求 $$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求 $$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$ 遍历数组，计算$arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。 行列均回文即要求 $$ arr[i][j] = arr[n-1-i][j] = arr[i][n-1-j] = arr[n-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。\n","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$ ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算1的对数即为cnt，计算需要修改的对数diff $cnt%4==0$ 1的个数能被4整除，结果计入$diff$即可 $cnt%4==2$ ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算1的对数即为cnt，计算需要修改的对数diff $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果即可 $cnt%4==2$ 1的个数不能4整除，如果diff不为0， ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数diff $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果即可 $cnt%4==2$ 1的个数不能4整除， ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 代码 ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 [ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] ]\n遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"},{"content":"Leetcode 3240 原题链接\n题目要求所有的行和列都是回文，又限制1的个数需要被4整除。\n行列均回文即要求 $$ arr[i][j] = arr[m-1-i][j] = arr[i][n-1-j] = arr[m-1-i][n-1-j] $$ 遍历数组，计算$cnt1=arr[i][j] + arr[n-1-i][j] + arr[i][n-1-j] + arr[n-1-i][n-1-j]$的和，和即为1的个数，将$min(result, cnt1)$计入结果。 如果为偶数行偶数列，此时已经计算完毕，反之 中心元素必须为0，$result+=arr[m/2][n/2]$, $arr[m/2][n/2]=0$时不会计入修改次数所以直接相加即可 计算中心行或中心列，先计算匹配的1个数，记为$cnt$，计算需要修改的对数$diff$ $cnt%4==0$ 1的个数能被4整除，$diff$对全改为0，计入结果 $cnt%4==2$ 1的个数不能4整除， $diff==0$，将$cnt%4$余下的两个改为0即可，$diff!=0$ 选择diff中的一对改为1，其余的改为0即可 class Solution { public: int minFlips(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { /* grid[i][j]=grid[m-i-1][j] 列相等 grid[i][j]=grid[i][n-j-1] 行相等 grid[i][n-j-1] = grid[m-i-1][n-j-1] */ int m = grid.size(), n = grid[0].size(); int result = 0; for (int i = 0; i \u0026lt; m / 2; i++) { for (int j = 0; j \u0026lt; n / 2; j++) { int cnt1 = grid[i][j] + grid[i][n - 1 - j] + grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j]; // 计算的结果就是1的个数，将其变为0即可 result += min(cnt1, 4 - cnt1); // 全变为1或全变为0 } } if (m % 2 \u0026amp;\u0026amp; n % 2) { result += grid[m / 2][n / 2]; // 确保中间为0，如果为0，+0不会变化，如果为1，+1变换次数+1 } /* 单独讨论奇数行和奇数列 镜像位置如果都一样，能不改就不改，先统计不改的位置有多少个1， 记作cnt1, 需要修改的为diff 分类讨论 cnt1%4 = 0 diff对全部改为0 or cnt1%4 = 2 diff\u0026gt;0 选择一对，改为1 diff==0 选择原来不改的一对，改为0即可 */ // 有奇数行 int diff = 0, cnt1 = 0; if (m % 2) { for (int i = 0; i \u0026lt; n / 2; i++) { if (grid[m / 2][i] != grid[m / 2][n - 1 - i]) diff++; else cnt1 += grid[m / 2][i] * 2; } } // 有奇数列 if (n % 2) { for (int i = 0; i \u0026lt; m / 2; i++) { if (grid[i][n / 2] != grid[m - 1 - i][n / 2]) diff++; else cnt1 += grid[i][n / 2] * 2; } } // 如果一致的1的个数能够整除4 返回 result+diff 即将diff中不为0的改为0 if (cnt1 % 4 == 0) return result + diff; // 如果一致的1的个数无法整除4 返回 result+(cnt1%4)+diff // 将整除4余下的个数全改为1即可 return result + (diff ? diff : cnt1 % 4); // return result + (diff ? diff : cnt1 % 4); } }; 时间复杂度 遍历数组，复杂度为O(m*n) 空间复杂度 只需要常数量的变量存储结果，所以未O(1) ","permalink":"http://localhost:1313/posts/leetcode-3240/","summary":"leetcode 中等题，需要一些分析","title":"Leetcode 3240"},{"content":"leetcode 3243 原题链接 本题的求解思路为：模拟即可\nclass Solution { public: int finalPositionOfSnake(int n, vector\u0026lt;string\u0026gt;\u0026amp; commands) { int startX = 0, startY = 0; for (auto\u0026amp; command : commands) { if (command == \u0026#34;RIGHT\u0026#34; || command == \u0026#34;LEFT\u0026#34;) startY = startY + (command == \u0026#34;LEFT\u0026#34; ? -1 : 1); else if (command == \u0026#34;UP\u0026#34; || command == \u0026#34;DOWN\u0026#34;) startX = startX + (command == \u0026#34;UP\u0026#34; ? -1 : 1); } return ((startX)*n - 1) + startY + 1; } }; 时间复杂度分析 遍历commands数字时间复杂度为O(N) 空间复杂度分析 常量的存储空间 O(1) ","permalink":"http://localhost:1313/posts/leetcode-3248/","summary":"leetcode 每日一题，简单题","title":"Leetcode 3248"},{"content":"leetcode 3243 原题链接 本题的求解思路为：每次更新一条边就要进行一次求起点到终点的最短路径。\nclass Solution{ private: int bfs(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp;neighbor) { vector\u0026lt;int\u0026gt; dist(n,-1); // 定义每个点到起点的距离 queue\u0026lt;int\u0026gt; q; // 用于bfs遍历的队列 q.push(0); // 将起点加入队列 dist[0]=0; // 0~0 距离为0 while(!q.empty()) { int x = q.front(); // 取出当前起点 q.pop(); for(auto \u0026amp;y: neighbor[x]) // 遍历下一个节点 { if(dist[y]!=-1) continue; // 如果已经访问过了，直接跳过 q.push(y); dist[y] = dist[x]+1; // 计算0到x的距离，+1 } } return dist[n-1]; } public: vector\u0026lt;int\u0026gt; shortestDistanceAfterQueries(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; queries) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; graph(n); // 定义图 vector\u0026lt;int\u0026gt; result; // 定义结果集 for (int i = 0; i \u0026lt; n - 1; i++) { graph[i].emplace_back(i+1); // 建图 } for (auto\u0026amp; query : queries) { graph[query[0]].emplace_back(query[1]); // 插入边 result.emplace_back(bfs(n, graph)); // 计算图更新后的结果 } return result; } }; 时间复杂度分析 每次插入一条边，都要遍历一次 每次bfs，都需要遍历n+q次 时间复杂度为O(q*(n+q)) 空间复杂度分析 存储图和结果集，需要O(n+q)的空间 ","permalink":"http://localhost:1313/posts/leetcode-3243/","summary":"leetcode 每日一题 图的bfs求解 中等题","title":"Leetcode 3243"},{"content":"Hello World! This is my first post.\nprint(\u0026#34;Hello World!\u0026#34;) ","permalink":"http://localhost:1313/posts/my-first-post/","summary":"\u003cp\u003eHello World!\nThis is my first post.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;Hello World!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"My First Post"}]